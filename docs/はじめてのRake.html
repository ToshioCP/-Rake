<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="ToshioCP" />
  <title>はじめてのRake</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
<header id="title-block-header">
<h1 class="title">はじめてのRake</h1>
<p class="author">ToshioCP</p>
<p class="date">2022/7/25</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#タスク">タスク</a></li>
<li><a href="#ファイルタスク">ファイルタスク</a></li>
<li><a href="#ファイルリストパスマップディレクトリータスク">ファイルリスト、パスマップ、ディレクトリータスク</a></li>
<li><a href="#rakeの応用１cleanとclobber">Rakeの応用（１）、CleanとClobber</a></li>
<li><a href="#rakeの応用２名前空間">Rakeの応用（２）、名前空間</a></li>
<li><a href="#rakeのその他の機能">Rakeのその他の機能</a></li>
<li><a href="#マルチタスクとテストタスク">マルチタスクとテストタスク</a></li>
</ul>
</nav>
<h3 id="タスク">タスク</h3>
<p>このチュートリアルはRakeをはじめて学ぶ人を対象にしていますが、すでにRakeを知っている人にも役立つ内容になっています。 このチュートリアルの特長は</p>
<ul>
<li>Rakeの仕組みや動作にも立ち入って説明している</li>
<li>Rakeを使った実用的な例を扱っている</li>
</ul>
<p>このチュートリアルを通して、様々な開発にRakeを活用できる力をつけましょう。</p>
<p>文中に例として書かれているソースコードは、GitHubのレポジトリ<a href="https://github.com/ToshioCP/Rake-tutorial-for-beginners-jp">Rake tutorial for bginners jp</a>にありますので、ダウンロードして使ってください。</p>
<p>文中に［Ｒ］という記号で始まる段落は、「Ruby上級者向けの解説」です。 上級とは、ほぼ「クラスを記述できるレベル」を指します。 上級以外の方はこの部分を飛ばしてください。</p>
<h4 id="rakeのインストール">Rakeのインストール</h4>
<p>RakeはRubyのアプリケーションです。 Rubyのインストールについては<a href="https://www.ruby-lang.org/ja/documentation/installation/#package-management-systems">Rubyの公式ホームページ</a>を参考にしてください。 Rakeは「Rubyの標準添付ライブラリ」なので、インストールされたRubyの中に含まれることが多いですが、もしそうでないときは、</p>
<ul>
<li>Linuxディストリビューションのrubyパッケージをインストールした場合＝＞パッケージのrakeをインストール</li>
<li>別の方法でインストールした場合＝＞コマンドから「gem install rake」でインストール</li>
</ul>
<p>などの方法でインストールしてください。</p>
<h4 id="rakeとは">Rakeとは？</h4>
<p>Rakeは、Makeと同様の機能を、Rubyプログラムとして実装したアプリケーションです。</p>
<p>Makeは、Cでコンパイルするときに、コンパイル過程全体をコントロールするために開発されたプログラムです。 しかし、MakeはCだけではなく、いろいろなコンパイラやトランスレータ（ある形式から別の形式に変換するプログラム）を制御することができます。 便利なMakeですが、その文法はマニアックです。 初歩的な使い方をしているうちは、分かりやすいのですが、使えば使うほど分かりにくくなってきます。 例えばこんな感じです。</p>
<pre><code>application: $(OBJS)
    $(CC) -o $(@F) $(OBJS) $(LIBS)

$(OBJS): %.o: %.c $(HEADER)
    $(CC) -fPIC -c -o $(@F) $(CFLAGS) $&lt;</code></pre>
<p>それに対してRakeは</p>
<ul>
<li>Rubyの文法をそのまま使うことができる</li>
<li>したがって、分かりやすく柔軟な書き方ができる</li>
</ul>
<p>という利点があります。</p>
<h4 id="rakeの基本">Rakeの基本</h4>
<p>まず、コマンドの<code>rake</code>とカレントディレクトリに置く<code>Rakefile</code>というファイルがポイントになります。 rakeコマンドは引数にタスク名（タスクは後で説明します）をとり、</p>
<pre><code>$ rake hello</code></pre>
<p>などの形で使います。 この例では、引数<code>hello</code>はタスク名です。</p>
<p>このとき<code>rake</code>は次のことを順に実行します。</p>
<ul>
<li>Rakeの初期化をする</li>
<li>Rakefileをロード、実行する（Rakefileにはタスクの定義が書かれている）</li>
<li>コマンドライン引数の名前のタスクを呼び出す</li>
</ul>
<p>「Rakefileにタスクの定義を書く」ことが、rakeを使う際のポイントになります。 当然、コマンドラインから呼び出されるタスクはRakefileの中で定義されていなければなりません。</p>
<blockquote>
<p>[R]　「タスクの定義を書く」「タスクを定義する」などは、<a href="https://docs.ruby-lang.org/ja/3.0/library/rake.html">Rubyのドキュメント</a>で使われている言い回しです。 Rubyに熟練している人は、これが具体的に何を意味するか気になるかもしれません。 Ruby的には「Taskクラスのインスタンスを生成する」ことを意味します。</p>
</blockquote>
<h4 id="rakefileでのタスク定義">Rakefileでのタスク定義</h4>
<p>タスクはオブジェクトで、名前、事前タスク（前提条件）、アクションを持ってます。 事前タスクとアクションは無くても構いません。</p>
<p>それでは、まず名前だけを持っているタスクを作成してみましょう。 Rakefileに次のように書き込みます。</p>
<pre><code>task :simple_task</code></pre>
<p><code>task</code>はタスクを定義するためのコマンド（命令）だと考えてください。 一般に「コマンド」はプログラム言語において、コンピュータに何かをさせるためのものです。 例えば、Shellでは、「cd」はカレント・ディレクトリを移動する「コマンド」です。 「cd /var」によって、カレントディレクトリが「/var」に移動しますが、それは「<code>/var</code>引数を与えて<code>cd</code>コマンドを実行した」ことの結果なのです。</p>
<p>同様に「task」コマンドには引数「:simple_task」が与えられています。 そして「taskコマンドを実行することにより、simple_taskを名前とするタスクが作成される」のです。 なお、引数の<code>:simple_task</code>はシンボルですが、文字列を使っても構いません。</p>
<pre><code>task &quot;simple_task&quot;</code></pre>
<p>両者に対してtaskコマンドが作成するタスクは全く同じです。</p>
<p>実は、taskコマンドは、Rubyの文法から見ると、taskメソッドの呼び出しで、<code>:simple_task</code>はtaskメソッドへの引数です。 ですので、今後はtaskを「コマンド」あるいは「メソッド」ということがありますが、</p>
<ul>
<li>「コマンド」は、taskの「タスク作成」機能に注目している場合</li>
<li>「メソッド」は、Rubyの文法上の機能に注目している場合</li>
</ul>
<p>で使い分けをしています。 細かいことになるので、あまり気にしなくても構いません。</p>
<blockquote>
<p>[R]　Rubyの文法から見た場合、<code>task</code>コマンドは「メソッド呼び出し」で、<code>:simple_task</code>はtaskメソッドの引数です。 Rubyではメソッド呼び出しの引数にカッコを付けても付けなくても良いのでこのように書けるのです。 もしカッコを付けるのならば、</p>
<pre><code>task(&quot;simple_task&quot;)</code></pre>
<p>となります。 （taskとカッコの間にはスペースを入れない）。 どちらでも定義できますが、カッコ無しを用いるのが良いです。</p>
<p>「タスクを定義する」とは「Taskクラスのインスタンスを生成する」ことです。 インスタンスの生成には通常newメソッドが使われますが、Task.newよりtaskメソッドの方が便利です。 なお、taskメソッドでは、その実行の中で「Task.new」が呼び出され、タスクのインスタンスが生成される仕組みになっています。</p>
</blockquote>
<p>タスク「simple_task」には事前タスクとアクションは定義されていません。</p>
<p>コマンドラインからタスクを実行してみましょう。 （注：レポジトリのexampleフォルダ内のRakefileの使い方はこのセクションの最後に書いてあります）。</p>
<pre><code>$ rake simple_task</code></pre>
<p>タスクは呼び出されているのですが、アクションが無いため、見た目には何も起こりません。 タスクが定義できているかどうかは、次のようにするとわかります。</p>
<pre><code>$ rake -AT
rake simple_task  #</code></pre>
<p>オプションATは登録されているすべてのタスクを表示します。 これで、simple_taskが定義されていることがわかりました。</p>
<p>この例を読者自身が作って実行するのは容易にできますが、このレポジトリのexampleフォルダにすでにRakefileが用意されています。 ここでその使い方を説明しておきましょう。</p>
<p>’example/example1`にカレントディレクトリを移動します。</p>
<pre><code>$ cd example/example1
$ ls
Rakefile1  Rakefile2  Rakefile3  Rakefile4</code></pre>
<p>フォルダ内にある<code>Rakefile1</code>が先程のRakefileになります。</p>
<pre><code>$ cat Rakefile1
task :simple_task</code></pre>
<p>ファイル名がRakefileでなく「Rakefil1」と「1」がついているため、単に「rake simple_task」では「Rakefile1」を読んでくれません。 そこで、<code>-f</code>オプションを使ってRakefileを指定します。</p>
<pre><code>$ rake -f Rakefile1 simple_task
$ rake -f Rakefile1 -AT
rake simple_task  # </code></pre>
<p>今後も、exampleフォルダ内のRakefileを使うときには、ファイル名の指定が必要になります。</p>
<h4 id="アクション">アクション</h4>
<p>アクションは、taskメソッド呼び出しのブロックで表します。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a>task <span class="st">:hello</span> <span class="kw">do</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>  print <span class="st">&quot;Hello world!\n&quot;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a><span class="kw">end</span></span></code></pre></div>
<p>このタスクは<code>hello</code>という名前です。 helloには事前タスクはありません。 アクションは「Hello world!」と画面表示する、というものです。</p>
<p>では、このタスクを実行してみましょう。 （<code>example/example1</code>フォルダ内の<code>Rakefile2</code>を<code>-f</code>オプションで指定してください）。</p>
<pre><code>$ rake hello
Hello world!</code></pre>
<p>タスクhelloが呼び出され、そのアクションが実行されて「Hello world!」の文字列が表示されました。</p>
<blockquote>
<p>[R]　Rubyにはブロックを（１）波カッコ（<code>{</code>と<code>}</code>）で表す（２）<code>do</code>と<code>end</code>で表す、の2つの方法があります。 Rakefileではどちらも動作しますが、読みやすさの点から<code>do</code>と<code>end</code>を使うのが良いでしょう。 また、波カッコを使う場合、次のように書くと動作しません。</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a>task <span class="st">:hello</span> {print <span class="st">&quot;Hello world!\n&quot;</span>}</span></code></pre></div>
<p>これは、do-endより波カッコの方が強く結合するために起こるエラーです。 <a href="https://docs.ruby-lang.org/ja/3.0/doc/spec=2fcall.html#block">Rubyのドキュメント</a>が参考になるので見てください。 これを解消するには、引数にカッコをつけます。</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a>task(<span class="st">:hello</span>) {print <span class="st">&quot;Hello world!\n&quot;</span>}</span></code></pre></div>
<p>Rakeでは、「taskがあたかもコマンドであるかのように表現したい」ということがあります。 波カッコを使うとそれができませんから、動作はするけれども推奨はできないのです。</p>
<p>RakeはRuby文法の自由さ（引数のカッコを省略できるなど）を使って、taskなどのコマンドを提供しています。 このように、特定の分野のために作られたコマンドをもつ言語を「DSL（Domain-Specific Language）」といいます。 do-end推奨の背景にはDSLの考え方があります。</p>
</blockquote>
<h4 id="事前タスク">事前タスク</h4>
<p>あるタスクが事前タスクを持っている場合、そのタスクが呼び出され（実行され）る前に事前タスクを呼び出します。</p>
<p>タスクの定義は</p>
<pre><code>task タスク名 =&gt; 事前タスク（の配列）do
  アクション
end</code></pre>
<p>のようになります。</p>
<p>「タスク名=&gt;事前タスク（の配列）」のところは、Rubyのハッシュです。 メソッド呼出の末尾にハッシュを渡す場合は カッコ（<code>{</code>と<code>}</code>） を省略することができます。 省略しなければ「{タスク名 =&gt; 事前タスク（の配列）}」となりますが、これでも動作します。</p>
<p>また、タスク名がシンボルの場合、例えば「:abc =&gt; “def”」と書くのを「abc: “def”」と書くことができます。 同様に、「:abc =&gt; :def」と「abc: :def」は同じです。</p>
<p>次の例では、firstとsecondという2つのタスクがあり、firstがsecondの事前タスクになっています。</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a>task <span class="st">second: :first</span> <span class="kw">do</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a>  print <span class="st">&quot;Second.\n&quot;</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a><span class="kw">end</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a>task <span class="st">:first</span> <span class="kw">do</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true"></a>  print <span class="st">&quot;First.\n&quot;</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true"></a><span class="kw">end</span></span></code></pre></div>
<p>タスクsecondを呼び出すと、事前タスクであるfirstがその前に呼び出されます。</p>
<pre><code>firstを実行　＝＞　secondを実行</code></pre>
<p>という順になります。</p>
<pre><code>$ rake second
First.
Second.</code></pre>
<p>（<code>example/example1</code>ファルダでは、<code>Rakefile3</code>を<code>-f</code>オプションで指定してください）。</p>
<h4 id="rakefileの例">Rakefileの例</h4>
<p>歌川さんの<a href="https://blog.utgw.net/entry/2022/06/22/221311">味玉のレシピをMakefileで記述する</a>が面白かったので、そのRake版を作ってみました。</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span class="co"># 味玉をつくる</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a>task :お湯を湧かす <span class="kw">do</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a>  print <span class="st">&quot;お湯を湧かします\n&quot;</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true"></a><span class="kw">end</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true"></a></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true"></a>task 卵を茹でる: :お湯を湧かす <span class="kw">do</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true"></a>  print <span class="st">&quot;卵を茹でます\n&quot;</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true"></a><span class="kw">end</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true"></a></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true"></a>task :<span class="st">&#39;8分待つ&#39;</span> =&gt; :卵を茹でる <span class="kw">do</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true"></a>  print <span class="st">&quot;8分待ちます\n&quot;</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true"></a><span class="kw">end</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true"></a></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true"></a>task ボウルに氷を入れる: :<span class="st">&#39;8分待つ&#39;</span> <span class="kw">do</span></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true"></a>  print <span class="st">&quot;ボウルに氷を入れます\n&quot;</span></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true"></a><span class="kw">end</span></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true"></a></span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true"></a>task ボウルに水を入れる: :ボウルに氷を入れる <span class="kw">do</span></span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true"></a>  print <span class="st">&quot;ボウルに水を入れます\n&quot;</span></span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true"></a><span class="kw">end</span></span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true"></a></span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true"></a>task ボウルに卵を入れる: :ボウルに水を入れる <span class="kw">do</span></span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true"></a>  print <span class="st">&quot;ボウルに卵を入れます\n&quot;</span></span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true"></a><span class="kw">end</span></span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true"></a></span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true"></a>task 卵の殻を剥く: :ボウルに卵を入れる <span class="kw">do</span></span>
<span id="cb19-28"><a href="#cb19-28" aria-hidden="true"></a>  print <span class="st">&quot;卵の殻を剥きます\n&quot;</span></span>
<span id="cb19-29"><a href="#cb19-29" aria-hidden="true"></a><span class="kw">end</span></span>
<span id="cb19-30"><a href="#cb19-30" aria-hidden="true"></a></span>
<span id="cb19-31"><a href="#cb19-31" aria-hidden="true"></a>task :ジップロックに日付を書く <span class="kw">do</span></span>
<span id="cb19-32"><a href="#cb19-32" aria-hidden="true"></a>  print <span class="st">&quot;ジップロックに日付を書きます\n&quot;</span></span>
<span id="cb19-33"><a href="#cb19-33" aria-hidden="true"></a><span class="kw">end</span></span>
<span id="cb19-34"><a href="#cb19-34" aria-hidden="true"></a></span>
<span id="cb19-35"><a href="#cb19-35" aria-hidden="true"></a>task ジップロックにめんつゆを入れる: [:ジップロックに日付を書く, :卵の殻を剥く] <span class="kw">do</span></span>
<span id="cb19-36"><a href="#cb19-36" aria-hidden="true"></a>  print <span class="st">&quot;ジップロックにめんつゆを入れます\n&quot;</span></span>
<span id="cb19-37"><a href="#cb19-37" aria-hidden="true"></a><span class="kw">end</span></span>
<span id="cb19-38"><a href="#cb19-38" aria-hidden="true"></a></span>
<span id="cb19-39"><a href="#cb19-39" aria-hidden="true"></a>task ジップロックに卵を入れる: :ジップロックにめんつゆを入れる <span class="kw">do</span></span>
<span id="cb19-40"><a href="#cb19-40" aria-hidden="true"></a>  print <span class="st">&quot;ジップロックに卵を入れます\n&quot;</span></span>
<span id="cb19-41"><a href="#cb19-41" aria-hidden="true"></a><span class="kw">end</span></span>
<span id="cb19-42"><a href="#cb19-42" aria-hidden="true"></a></span>
<span id="cb19-43"><a href="#cb19-43" aria-hidden="true"></a>task 一晩寝かせる: :ジップロックに卵を入れる <span class="kw">do</span></span>
<span id="cb19-44"><a href="#cb19-44" aria-hidden="true"></a>  print <span class="st">&quot;一晩寝かせます\n&quot;</span></span>
<span id="cb19-45"><a href="#cb19-45" aria-hidden="true"></a><span class="kw">end</span></span>
<span id="cb19-46"><a href="#cb19-46" aria-hidden="true"></a></span>
<span id="cb19-47"><a href="#cb19-47" aria-hidden="true"></a>task 味玉: :一晩寝かせる <span class="kw">do</span></span>
<span id="cb19-48"><a href="#cb19-48" aria-hidden="true"></a>  print <span class="st">&quot;味玉ができました\n&quot;</span></span>
<span id="cb19-49"><a href="#cb19-49" aria-hidden="true"></a><span class="kw">end</span></span></code></pre></div>
<p>実行してみます。 （<code>example/example1</code>フォルダでは、<code>Rakefile4</code>を<code>-f</code>オプションで指定してください）。</p>
<pre><code>$ rake 味玉
ジップロックに日付を書きます
お湯を湧かします
卵を茹でます
8分待ちます
ボウルに氷を入れます
ボウルに水を入れます
ボウルに卵を入れます
卵の殻を剥きます
ジップロックにめんつゆを入れます
ジップロックに卵を入れます
一晩寝かせます
味玉ができました</code></pre>
<h4 id="タスクの呼び出しは一度だけ">タスクの呼び出しは一度だけ</h4>
<p>すでに呼び出されたタスクは実行されません。 つまり「タスクの実行は1度だけ」です。</p>
<p>例えば、味玉のRakefileで</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a>task ジップロックに卵を入れる: :ジップロックにめんつゆを入れる <span class="kw">do</span></span></code></pre></div>
<p>のところを</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a>task ジップロックに卵を入れる: [:ジップロックにめんつゆを入れる, :卵の殻を剥く] <span class="kw">do</span></span></code></pre></div>
<p>とすると、「卵の殻を剥く」が2箇所で事前タスクになります。 呼び出しが2回ありますが、実行は1回だけなので、実行結果は同じになります。</p>
<blockquote>
<p>[R]　タスクのインスタンス・メソッドに「invoke」（呼び出し）と「execute」（実行）があります。 invokeはアクションを一度だけ実行しますが、executeはそのメソッドが呼ばれた回数だけ何度でも実行します。 それで、<a href="https://docs.ruby-lang.org/ja/3.0/library/rake.html">Rubyのドキュメント</a>では「呼び出し」と「実行」の2つの言葉を区別して使っているようです。 このチュートリアルでは使い分けが曖昧な箇所がありますが、大きな混乱はないと思っています。 なお、invokeは自身のタスクを呼び出す前に事前タスクを呼び出しますが、executeは事前タスクを呼び出しません。</p>
</blockquote>
<h4 id="タスク名には文字列も使える">タスク名には文字列も使える</h4>
<p>今までタスク名にシンボルを使ってきましたが、文字列を使うこともできます。</p>
<pre><code>task &quot;simple_task&quot;
task &quot;second&quot; =&gt; &quot;first&quot;</code></pre>
<p>このような書き方も可能です。 シンボルでハッシュを記述するには「{abc: :def}」のような書き方ができますが、シンボルの最初に数字がくるときにはこれが使えません。 「{0abc: :def}」や「{abc: :2def}」はシンタックス・エラーになります。 「{:‘0abc’ =&gt; :def}」「{abc: :‘2def’}」のように書かなければなりません。 文字列ではこのような心配がなく、シングルクォートあるいはダブルクォートで囲めばエラーになりません。</p>
<p>慣例としては</p>
<pre><code>task abc: %w[def ghi]</code></pre>
<p>の書き方が多く用いられるようです。 %wは空白で区切られた文字列の配列を返します。 <code>%w[def ghi]</code>と<code>["def", "ghi"]</code>は同じです。 Rubyのドキュメントの<a href="https://docs.ruby-lang.org/ja/3.0/doc/spec=2fliteral.html#percent">%記法</a>を参考にしてください。</p>
<p>味玉の例で%記法を使うと</p>
<pre><code>task ジップロックにめんつゆを入れる: %w[ジップロックに日付を書く 卵の殻を剥く] do</code></pre>
<p>となります。</p>
<h3 id="ファイルタスク">ファイルタスク</h3>
<p>この章ではファイルタスクを説明します。 ファイルタスクはRakeにおいて最も重要なタスクです。 ファイルタスクのためにRakeがあると言っても過言ではありません。</p>
<h4 id="ファイルタスクとは">ファイルタスクとは？</h4>
<p>ファイルタスクはタスクの一種です。 ファイルタスクにも一般のタスクと同じように「名前」「事前タスク」「アクション」があります。 一般のタスクとの違いは次の3点です。</p>
<ul>
<li>ファイルタスクの「名前」は（ファイルの）パスを表す。</li>
<li>ファイルタスクにはそのアクションを実行するかどうかについての条件がある</li>
<li>ファイルタスクはfileメソッドで定義する（一般のタスクはtaskメソッド）</li>
</ul>
<p>これ以外は一般のタスクと同じように「タスクの呼び出しの前に事前タスクを呼び出す」「タスクの実行は一度だけ」です。</p>
<p>それでは、ファイルタスクのアクションを実行する上での条件とは何でしょうか。 条件は2つあります。</p>
<ul>
<li>タスクの名前が示すファイルが存在しない</li>
<li>タスクの名前が示すファイルのmtime（ファイル内容変更時間）が、その事前タスク（複数ある場合はそのどれか）のmtimeよりも古い。 ただし、事前タスクがファイルタスクではない場合（一般のタスクである場合）はmtimeの代わりに現在時刻を用いる。 したがって、事前タスクが一般のタスクを含む場合は、そのファイルタスクは常に実行される。</li>
</ul>
<blockquote>
<p>［Ｒ］ここでいうmtime（ファイル内容変更時間）はRubyのFile.mtimeメソッドの値です。 Linuxのファイルにはatime, mtime, ctimeの3つのタイムスタンプがあります。</p>
<ul>
<li>atime 最後にアクセスされた時刻</li>
<li>mtime 最後に変更された時刻</li>
<li>ctime 最後にinodeが変更された時刻</li>
</ul>
<p>RubyのFile.mtimeメソッドはこのmtimeを返します。（C言語で書かれたオリジナルのRubyはCのシステムコールでその値を取得しています）</p>
</blockquote>
<h4 id="ファイルのバックアップ">ファイルのバックアップ</h4>
<p>それでは具体例を見ていきましょう。 ここではテキストファイル「a.txt」のバックアップファイル「a.bak」を作ることを考えます。 単純にファイルをコピーすれば良いので、</p>
<pre><code>$ cp a.txt a.bak</code></pre>
<p>で出来ますが、練習のためにRakefileにしてみます。</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true"></a>file <span class="st">&quot;a.bak&quot;</span> =&gt; <span class="st">&quot;a.txt&quot;</span> <span class="kw">do</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true"></a>  cp <span class="st">&quot;a.txt&quot;</span>, <span class="st">&quot;a.bak&quot;</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true"></a><span class="kw">end</span></span></code></pre></div>
<p>このRakefileの内容を説明します。</p>
<ul>
<li>fileメソッドでファイルタスク「a.bak」を定義しています</li>
<li>a.bakの事前タスクは「a.txt」です。</li>
<li>タスク「a.bak」のアクションは<code>cp "a.txt", "a.bak"</code>です。</li>
</ul>
<p>cpメソッドは第1引数ファイルを第2引数ファイルにコピーするメソッドです。 このメソッドはFileUtilsモジュールで定義されています。 FileUtilsはRubyの標準添付ライブラリですが、ビルトインではないため、通常は<code>require 'fileutils'</code>をプログラムに書かなければなりません。 しかし、Rakeが自動的にrequireするのでRakefileにそれを書く必要はありません。</p>
<p>タスク「a.bak」が呼び出されると、その実行の前に事前タスク「a.txt」が呼び出されます。 ところが、Rakefileにはタスク「a.txt」の定義が書かれていません。 Rakeは事前タスクの定義が無いときにどのように振る舞うのでしょうか？ Rakeはファイル「a.txt」存在するならば、ファイルタスク「a.txt」を名前だけのタスク（事前タスクとアクションは無い）として自ら定義します。 そしてそのタスクを呼び出しますが、アクションが無いので何もせずに「a.bak」の呼び出しに戻ります。 もし「a.txt」が存在しなければエラーになります。</p>
<p>それでは、コマンドラインから実行してみましょう。 （<code>example/example2</code>で試すには、<code>rake -f Rakefile1 a.bak</code>としてください。 <code>ls</code>の結果は<code>example/example2</code>では異なります）</p>
<pre><code>$ ls
Rakefile  a.txt
$ rake a.bak
cp a.txt a.bak
$ ls
Rakefile  a.bak  a.txt
$ diff a.bak a.txt
$ rake a.bak
$</code></pre>
<ul>
<li>最初はカレントディレクトリには「Rakefile」と「a.txt」の2つのファイルだけがあります。</li>
<li>rakeを実行すると、「a.txt」が「a.bak」にコピーされます。</li>
<li>ディレクトリをリスティングすると、「a.bak」が新たに加わっています。</li>
<li>diffを使って「a.bak」と「a.txt」を比較すると、同じ内容のファイルなので、何もメッセージが出ません</li>
<li>再びrakeを実行しますが、「a.bak」が「a.txt」より後に作成されているため、アクションは実行されません</li>
</ul>
<p>ここでは、最も基本的なファイルタスクの使い方を学びました。</p>
<h4 id="複数ファイルのバックアップ">複数ファイルのバックアップ</h4>
<p>次に3つのファイルをバックアップするRakefileについて考えてみましょう。 新たに「b.txt」と「c.txt」というファイルを作っておきます。 Rakefileのもっとも初歩的な書き方は、次のようなものでしょう。</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true"></a>file <span class="st">&quot;a.bak&quot;</span> =&gt; <span class="st">&quot;a.txt&quot;</span> <span class="kw">do</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true"></a>  cp <span class="st">&quot;a.txt&quot;</span>, <span class="st">&quot;a.bak&quot;</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true"></a><span class="kw">end</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true"></a></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true"></a>file <span class="st">&quot;b.bak&quot;</span> =&gt; <span class="st">&quot;b.txt&quot;</span> <span class="kw">do</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true"></a>  cp <span class="st">&quot;b.txt&quot;</span>, <span class="st">&quot;b.bak&quot;</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true"></a><span class="kw">end</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true"></a></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true"></a>file <span class="st">&quot;c.bak&quot;</span> =&gt; <span class="st">&quot;c.txt&quot;</span> <span class="kw">do</span></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true"></a>  cp <span class="st">&quot;c.txt&quot;</span>, <span class="st">&quot;c.bak&quot;</span></span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true"></a><span class="kw">end</span></span></code></pre></div>
<p>ここには、3つのファイルタスクが定義されています。 それを実行してみましょう。 （<code>example/example2</code>では<code>-f Rakefile2</code>をつけて実行してください）</p>
<p>あらかじめ、「a.bak」は削除しておきます。</p>
<pre><code>$ ls
Rakefile  a.txt  b.txt  c.txt
$ rake a.bak
cp a.txt a.bak
$ rake b.bak
cp b.txt b.bak
$ rake c.bak
cp c.txt c.bak
$ ls
Rakefile  a.bak  a.txt  b.bak  b.txt  c.bak  c.txt</code></pre>
<p>皆さん既に気がついたことと思います。 「自分だったらこんなことしない。rakeを3回使うのならcpを3回使うのと変わらないじゃないか」。 その通りです。</p>
<p>一度のRake実行で3個のファイルをコピーしたいですね。 これは、一般のタスクと3つのファイルタスクを関連付けることで実現できます。 最初に「copy」タスクを作り、3つのファイルタスクをその事前タスクにしてみましょう。</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true"></a>task <span class="st">copy: </span><span class="ot">%w[</span><span class="st">a.bak b.bak c.bak</span><span class="ot">]</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true"></a></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true"></a>file <span class="st">&quot;a.bak&quot;</span> =&gt; <span class="st">&quot;a.txt&quot;</span> <span class="kw">do</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true"></a>  cp <span class="st">&quot;a.txt&quot;</span>, <span class="st">&quot;a.bak&quot;</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true"></a><span class="kw">end</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true"></a></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true"></a>file <span class="st">&quot;b.bak&quot;</span> =&gt; <span class="st">&quot;b.txt&quot;</span> <span class="kw">do</span></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true"></a>  cp <span class="st">&quot;b.txt&quot;</span>, <span class="st">&quot;b.bak&quot;</span></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true"></a><span class="kw">end</span></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true"></a></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true"></a>file <span class="st">&quot;c.bak&quot;</span> =&gt; <span class="st">&quot;c.txt&quot;</span> <span class="kw">do</span></span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true"></a>  cp <span class="st">&quot;c.txt&quot;</span>, <span class="st">&quot;c.bak&quot;</span></span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true"></a><span class="kw">end</span></span></code></pre></div>
<p>実行してみます。 （<code>example/example2</code>では<code>-f Rakefile3</code>をつけて実行してください）</p>
<pre><code>$ rm *.bak
$ rake copy
cp a.txt a.bak
cp b.txt b.bak
cp c.txt c.bak</code></pre>
<p>一度のrake実行で3つのコピーができました。</p>
<p>リファクタリングしましょう。 2つのことを改善します。</p>
<ul>
<li>トップレベルのタスクを「copy」から「default」に変えます。 「default」はrakeの引数が省略されたときに実行されるデフォルトのタスクです。</li>
<li>3つのファイルタスクをRubyのイテレーションを使って1つにまとめます。</li>
</ul>
<div class="sourceCode" id="cb33"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true"></a>backup_files =<span class="ot"> %w[</span><span class="st">a.bak b.bak c.bak</span><span class="ot">]</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true"></a></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true"></a>task <span class="st">default: </span>backup_files</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true"></a></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true"></a>backup_files.each <span class="kw">do</span> |backup|</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true"></a>  source = backup.ext(<span class="st">&quot;.txt&quot;</span>)</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true"></a>  file backup =&gt; source <span class="kw">do</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true"></a>    cp source, backup</span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true"></a>  <span class="kw">end</span></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true"></a><span class="kw">end</span></span></code></pre></div>
<ul>
<li>はじめに、バックアップ・ファイルの配列を作り、「backup_files」という変数に代入しておきます。</li>
<li>トップレベルのタスクを「default」にします。</li>
<li>バックアップファイルの配列の一つひとつの要素を取り出すeachメソッドを用います。 取り出した要素がブロックのbackupパラメータに代入されます。</li>
<li>変数sourceに、backupの拡張子を「.txt」に変えたものを代入します。 「ext」メソッドはRakeがStringクラスに追加したメソッドで、拡張子を変更するものです。 元々のStringクラスには「ext」メソッドはありません。</li>
<li>fileコマンドでファイルタスクを定義します。 「each」メソッドで、ブロックが3回繰り返されるので、fileコマンドも3回実行され、「a.bak」「b.bak」「c.bak」の3つのファイルタスクが定義されます。</li>
</ul>
<p>実行してみます。 （<code>example/example2</code>では<code>-f Rakefile3</code>をつけて実行してください）</p>
<pre><code>$ rm *.bak
$ rake
cp a.txt a.bak
cp b.txt b.bak
cp c.txt c.bak
$ touch a.txt
$rake
cp a.txt a.bak
$</code></pre>
<ul>
<li>バックアップファイルをすべて削除します</li>
<li>rakeを実行すると、3つのファイル全てがコピーされます。</li>
<li>touchを使って「a.txt」のmtimeを更新します（現在時刻に設定する）</li>
<li>rakeを実行すると、「a.bak」のmtimeよりも「a.txt」のmtimeの方が新しいので、ファイルタスク「a.bak」のアクションを実行します。 他のファイルタスクはバックアップのmtimeの方が新しいので、アクションは実行されません。</li>
</ul>
<p>例の最後で「touch」を使ってmtimeを変更しましたが、通常はエディタでファイルを上書きするときにmtimeの更新が起こります。 つまり、元ファイルが新しくなるとファイルタスクのアクションを実行する条件が整うことになります。</p>
<p>少々リファクタリングを追加し、ブロックの中でタスクのインスタンスを使う方法を紹介します。</p>
<p>ファイルタスクの定義の部分を次のように変更します。</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true"></a>file backup =&gt; source <span class="kw">do</span> |t|</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true"></a>  cp t.source, t.name</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true"></a><span class="kw">end</span></span></code></pre></div>
<p>ブロックに新たにパラメータ「t」が加わりました。 「t」にはファイルタスク「backup」が代入されます。 （Ruby的にはそのインスタンスが代入されます）</p>
<p>taskメソッドのブロックでも同じパラメータが使えます。</p>
<p>タスクやファイルタスクには便利なメソッドがあります。</p>
<ul>
<li><code>name</code> タスクの名前を返す</li>
<li><code>prerequisites</code> 事前タスクの配列を返す</li>
<li><code>sources</code> 自身が依存するファイルのリストを返す</li>
<li><code>source</code> 自身が依存するファイルのリストの最初の要素を返す</li>
</ul>
<p>この他にもメソッドはありますが、よく使われるのは上の4つのメソッドです。</p>
<p>新しいファイルタスクの定義では、そのアクションが「t.source」から「t.name」にコピーするように変わっています。 これは、それぞれ「source」と「backup」になりますから、以前のファイルタスクと内容的には同じです。 （<code>example/example3</code>では<code>-f Rakefile5</code>をつけて実行してください）</p>
<h4 id="ルール">ルール</h4>
<p>これまでのバックアップは「.txt拡張子のファイルを.bak拡張子のファイルにコピーする」というものでした。 これを「a.bak」というファイル名にあてはめれば、「a.txtをa.bakにコピーする」というアクションを持つファイルタスクが得られます。 このように、ファイルタスクを作るための規則をルールと呼びます。 ルールは「rule」メソッドで定義できます。 具体的に「rule」を使ったRakefileの例を見てみましょう。</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true"></a>backup_files =<span class="ot"> %w[</span><span class="st">a.bak b.bak c.bak</span><span class="ot">]</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true"></a></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true"></a>task <span class="st">default: </span>backup_files</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true"></a></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true"></a>rule <span class="st">&#39;.bak&#39;</span> =&gt; <span class="st">&#39;.txt&#39;</span> <span class="kw">do</span> |t|</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true"></a>  cp t.source, t.name</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true"></a><span class="kw">end</span></span></code></pre></div>
<p>はじめの3行は今までと変わりません。 3行目の定義によると、defaultの事前タスクは「a.bak」「b.bak」「c.bak」ですが、それらのタスクの定義は書かれていません。 Rakeは、事前タスクの定義がないときは、その呼び出しの直前に事前タスクの定義を試みます。</p>
<ul>
<li>ルールが定義されていて、タスク名がルールに合致するときは、そのルールを用いてタスクを定義する</li>
<li>合致するルールが無く、タスク名が、その時点で存在するファイル名に一致すれば、タスク名のみ（事前タスクとアクションが無い）のファイルタスクを定義する</li>
<li>以上のどれでもなければ、エラーになる</li>
</ul>
<p>この例におけるルールは次のようになります。</p>
<ul>
<li>タスク名の拡張子が「.bak」である</li>
<li>依存するファイル名の拡張子が「.txt」である</li>
<li>アクションは、そのタスクの「t.source」（タスクが依存するファイルの配列の最初の要素）を「t.name」（タスク名＝ファイル名）にコピーする、ということである</li>
</ul>
<p>3つのタスク「a.bak」「b.bak」「c.bak」はすべてルールに合致するので、ルールに従ってタスクが定義されます。 それでは、実行してみましょう。 （<code>example/example2</code>では<code>-f Rakefile6</code>をつけて実行してください）</p>
<pre><code>$ rm *.bak
$ rake
cp a.txt a.bak
cp b.txt b.bak
cp c.txt c.bak
$</code></pre>
<p>今までと同じように動作しました。</p>
<p>ruleメソッドの<code>'.bak'</code>の部分は、Rakeが正規表現<code>/\.bak$/</code>に変換します。 この正規表現とタスク名の「a.bak」「b.bak」「c.bak」が比較されるのです。 そこで、最初から正規表現にしておいてもルールを定義できます。 （<code>example/example2</code>では<code>-f Rakefile7</code>をつけて実行してください）</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true"></a>rule <span class="ot">/\.bak$/</span> =&gt; <span class="st">&#39;.txt&#39;</span> <span class="kw">do</span> |t|</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true"></a>  cp t.source, t.name</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true"></a><span class="kw">end</span></span></code></pre></div>
<blockquote>
<p>[R]　このことは、「拡張子の一致」だけでなく「任意のパターンに対する一致」を可能にします。 例えば、バックアップファイルを「~a.txt」のように先頭にチルダ「<code>~</code>」を付けるように変更することが可能です。</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true"></a>backup_files =<span class="ot"> %w[</span><span class="st">~a.txt ~b.txt ~c.txt</span><span class="ot">]</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true"></a></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true"></a>task <span class="st">default: </span>backup_files</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true"></a></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true"></a>rule <span class="ot">/^~.*\.txt$/</span> =&gt; <span class="st">&#39;.txt&#39;</span> <span class="kw">do</span> |t|</span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true"></a>  cp t.source, t.name</span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true"></a><span class="kw">end</span></span></code></pre></div>
<p>ところが、これではエラーになってしまいます。</p>
<pre><code>$ rake
rake aborted!
Rake::RuleRecursionOverflowError: Rule Recursion Too Deep: [~a.txt =&gt; ~a.txt =&gt; ~a.txt =&gt; ~a.txt =&gt; ~a.txt =&gt; ~a.txt =&gt; ~a.txt =&gt; ~a.txt =&gt; ~a.txt =&gt; ~a.txt =&gt; ~a.txt =&gt; ~a.txt =&gt; ~a.txt =&gt; ~a.txt =&gt; ~a.txt =&gt; ~a.txt =&gt; ~a.txt]

Tasks: TOP =&gt; default
(See full trace by running task with --trace)</code></pre>
<p>これは、<code>=&gt; '.txt'</code>の部分が良くないのです。 これだと「<code>~a.txt</code>」の依存ファイルが、タスク名の「<code>~a.txt</code>」の拡張子を「.txt」に変えたものである「<code>~a.txt</code>」になってしまいます。 つまりタスク名と依存タスク名が同じなので、ルールを適用するときに無限ループに陥ってしまうのです。 Rakeでは、16回のループが起きたときにエラーとして処理します。</p>
<p>これを避けるには、依存ファイルをProcオブジェクトで定義します。</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true"></a>backup_files =<span class="ot"> %w[</span><span class="st">~a.txt ~b.txt ~c.txt</span><span class="ot">]</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true"></a></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true"></a>task <span class="st">default: </span>backup_files</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true"></a></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true"></a>rule <span class="ot">/^~.*\.txt$/</span> =&gt; proc {|tn| tn.sub(<span class="ot">/^~/</span>,<span class="st">&quot;&quot;</span>)} <span class="kw">do</span> |t|</span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true"></a>  cp t.source, t.name</span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true"></a><span class="kw">end</span></span></code></pre></div>
<p>procメソッドのブロックの引数には、タスク名（例えば「~a.txt」）がRakeによって渡されます。 Procインスタンスの生成には、lambdaメソッドや「-&gt;( ){ }」（<a href="https://docs.ruby-lang.org/ja/3.0/doc/symref.html#rangl">Rubyのドキュメント参照</a>）も使えます。</p>
<p>実行してみます。 （<code>example/example2</code>では<code>-f Rakefile8</code>をつけて実行してください）</p>
<pre><code>$ rake
cp a.txt ~a.txt
cp b.txt ~b.txt
cp c.txt ~c.txt
$</code></pre>
</blockquote>
<h3 id="ファイルリストパスマップディレクトリータスク">ファイルリスト、パスマップ、ディレクトリータスク</h3>
<p>このセクションではファイルタスクをサポートする便利な機能を解説します。 具体的には「ファイルリスト」「パスマップ」「ディレクトリータスク」です。</p>
<h4 id="ファイルリスト">ファイルリスト</h4>
<p>ファイルリストは、ファイル名の配列のようなオブジェクトです。 文字列の配列と同様の操作ができ、さらにいくつかの便利な機能を備えています。</p>
<p>まずファイルリストのインスタンスの作り方から説明しましょう。 クラス名「FileList」に<code>[ ]</code>をつけ、そのカッコのなかにファイル名をコンマで区切って書きます。 これで、そのファイルを持つファイルリストができます。</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true"></a>files = <span class="dt">FileList</span>[<span class="st">&quot;a.txt&quot;</span>, <span class="st">&quot;b.txt&quot;</span>]</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true"></a>p files</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true"></a></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true"></a>task <span class="st">:default</span></span></code></pre></div>
<p>デフォルトタスクを定義しないと、コマンドラインから<code>rake</code>を実行したときにエラーになります。 それを防ぐために何もしないデフォルトタスクを定義してあります。</p>
<p>ここでRakeの動作をもう一度確認しておきましょう。</p>
<ol type="1">
<li>Rakeの実行環境を初期化する</li>
<li>Rakefileをロードする。このときRakefileは（Rubyコードとして）実行される</li>
<li>デフォルトタスクを呼び出す</li>
</ol>
<p>2番めのRakefileロード時に、ファイルリストが作成され、表示され、デフォルトタスクの定義が行われます。 これらは「タスク呼び出し」前に行われていることに注意してください。</p>
<p>実行してみます。 （<code>example/example3</code>では<code>-f Rakefile1</code>をつけて実行してください）</p>
<pre><code>$ rake
[&quot;a.txt&quot;, &quot;b.txt&quot;]
$</code></pre>
<p>シェルで良く使われるGlobパターンも使えます。</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true"></a>files = <span class="dt">FileList</span>[<span class="st">&quot;*.txt&quot;</span>]</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true"></a>p files</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true"></a></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true"></a>task <span class="st">:default</span></span></code></pre></div>
<p>実行してみます。 （<code>example/example3</code>では<code>-f Rakefile2</code>をつけて実行してください） <code>ls</code>や<code>rake</code>の結果はそのディレクトリに含まれるファイルによって異なります。 Rakefile3以降でも<code>ls</code>や<code>rake</code>の結果が異なることがあります）</p>
<pre><code>$ ls
 Rakefile   a.txt   b.txt   c.txt  &#39;~a.txt&#39;
$ rake
[&quot;a.txt&quot;, &quot;b.txt&quot;, &quot;c.txt&quot;, &quot;~a.txt&quot;]
$</code></pre>
<p>Globパターンについては<a href="https://docs.ruby-lang.org/ja/3.0/class/Dir.html#S_--5B--5D">Rubyのドキュメント</a>を参考にしてください。</p>
<h4 id="すべてのテキストファイルのバックアップ">すべてのテキストファイルのバックアップ</h4>
<p>すべてのテキストファイルをバックアップすることを考えてみます。 ここでは、「テキストファイル」を「拡張子が.txtのファイル」としておきます。 このとき、「すべて」というのは「現時点でのすべて」ではなく、「Rakeを実行する時点でのすべて」です。 将来テキストファイルが追加されたり、削除されたりする可能性がありますから、「現時点でのすべてのテキストファイル」と「Rakeを実行する時点でのすべてのテキストファイル」は同じとは限りません。 ですから、Rakefileの記述の中に、その時点でのテキストファイルを捕まえる仕組みを作らなければなりません。 それにはファイルリストを使います。</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true"></a>files = <span class="dt">FileList</span>[<span class="st">&quot;*.txt&quot;</span>]</span></code></pre></div>
<p>さて、この中に「~a.txt」が含まれていますが、これはオリジナルが「a.txt」であるバックアップファイルですから、コピーの対象から外します。 そのときにはexcludeメソッドを使います。</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true"></a>files = <span class="dt">FileList</span>[<span class="st">&quot;*.txt&quot;</span>]</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true"></a>files.exclude(<span class="st">&quot;~*.txt&quot;</span>)</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true"></a>p files</span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true"></a></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true"></a>task <span class="st">:default</span></span></code></pre></div>
<p>excludeメソッドは、与えられたパターンを自身の除外リストに加えます。 実行してみましょう。 （<code>example/example3</code>では<code>-f Rakefile3</code>をつけて実行してください）</p>
<pre><code>$ rake
[&quot;a.txt&quot;, &quot;b.txt&quot;, &quot;c.txt&quot;]
$</code></pre>
<p>「~a.txt」が取り除かれました。</p>
<p>今ファイルリストにはオリジナルのファイル（コピー元のファイル）がセットされました。 一方、ファイルタスクの名前はバックアップファイル名です。 例えば「a.txt」を「a.bak」にコピーするファイルタスクでは、</p>
<ul>
<li>タスク名は「a.bak」</li>
<li>依存ファイル名が「a.txt」</li>
</ul>
<p>です。 ファイルタスクを定義するためには、ファイルリストに含まれる「コピー元のファイル名」からタスク名である「コピー先のファイル名」を取得する必要があります。 それにはファイルタスクのextメソッドを使います。 extメソッドはファイルタスクに含まれる全てのファイルの拡張子を変更します。</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true"></a>names = sources.ext(<span class="st">&quot;.bak&quot;</span>)</span></code></pre></div>
<p>それではRakefileを書いてみましょう。</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true"></a>sources = <span class="dt">FileList</span>[<span class="st">&quot;*.txt&quot;</span>]</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true"></a>sources.exclude(<span class="st">&quot;~*.txt&quot;</span>)</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true"></a>names = sources.ext(<span class="st">&quot;.bak&quot;</span>)</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true"></a></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true"></a>task <span class="st">default: </span>names</span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true"></a></span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true"></a>rule <span class="st">&quot;.bak&quot;</span> =&gt; <span class="st">&quot;.txt&quot;</span> <span class="kw">do</span> |t|</span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true"></a>  cp t.source, t.name</span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true"></a><span class="kw">end</span></span></code></pre></div>
<p>実行してみます。 （<code>example/example3</code>では<code>-f Rakefile4</code>をつけて実行してください）</p>
<pre><code>$ rake
cp a.txt a.bak
cp b.txt b.bak
cp c.txt c.bak
$</code></pre>
<p>上手く動きました。 ここでテキストファイルを増やして、rakeを実行してみます。</p>
<pre><code>$ echo Appended text file. &gt;d.txt
$ rm *.bak
$ rake
cp a.txt a.bak
cp b.txt b.bak
cp c.txt c.bak
cp d.txt d.bak
$</code></pre>
<p>新しいファイル「d.txt」もコピーされました。 ということは、Rakefileが「Rake実行時点でのすべてのテキストファイル」をバックアップしたのが確認できた、ということです。</p>
<p>この例の「*.txt」ファイルをソース、「*.bak」ファイルをターゲットということがあります。 一般に、「ソースは存在するが、ターゲットは存在するとは限らない」ということがいえます。 そのため、Rakefileではまずソースを取得して、そのソースからターゲットを生成する、という方法が良く用いられます。</p>
<h4 id="パスマップ">パスマップ</h4>
<p>パスマップ・メソッドはファイルリストの強力なメソッドです。 元々はpathmapはStringオブジェクトのインスタンス・メソッドです。 これをFileListの各要素に対して実行するのがファイルリストのパスマップ・メソッドです。 パスマップは、その引数によって、様々な情報を返します。 よく使われる例をあげます。</p>
<ul>
<li>%p =&gt; 完全なパスを表します</li>
<li>%f =&gt; 拡張子付きのファイル名を表します。ディレクトリ名は含まれません。</li>
<li>%n =&gt; 拡張子なしのファイル名を表します。</li>
<li>%d =&gt; パスに含まれるディレクトリのリストを表します。</li>
</ul>
<p>パスマップの例示す前に、その準備としてカレントディレクトリに「src」ディレクトリを作り、その下に「a.txt」「b.txt」「c.txt」を作ります。</p>
<pre><code>$ mkdir src
$ touch src/a.txt src/b.txt src/c.txt
$ tree
.
├── Rakefile
├── a.bak
├── a.txt
├── b.bak
├── b.txt
├── c.bak
├── c.txt
├── d.bak
├── d.txt
├── src
│   ├── a.txt
│   ├── b.txt
│   └── c.txt
└── ~a.txt

1 directory, 14 files
$</code></pre>
<p>Rakefileを次のように書きます。</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true"></a>sources = <span class="dt">FileList</span>[<span class="st">&quot;src/*.txt&quot;</span>]</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true"></a>p sources.pathmap(<span class="st">&quot;%p&quot;</span>)</span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true"></a>p sources.pathmap(<span class="st">&quot;%f&quot;</span>)</span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true"></a>p sources.pathmap(<span class="st">&quot;%n&quot;</span>)</span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true"></a>p sources.pathmap(<span class="st">&quot;%d&quot;</span>)</span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true"></a></span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true"></a>task <span class="st">:default</span></span></code></pre></div>
<p>変数sourcesに代入されるファイルリスト・オブジェクトは「src/a.txt」「src/b.txt」「src/c.txt」を含みます。 では、実行してみます。 （<code>example/example3</code>では<code>-f Rakefile5</code>をつけて実行してください）</p>
<pre><code>$ rake
[&quot;src/a.txt&quot;, &quot;src/b.txt&quot;, &quot;src/c.txt&quot;]
[&quot;a.txt&quot;, &quot;b.txt&quot;, &quot;c.txt&quot;]
[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
[&quot;src&quot;, &quot;src&quot;, &quot;src&quot;]</code></pre>
<p>パスマップでは、単純な文字列置換を行うための置換パターンを表すパラメータを指定することができます。 パターンと置換文字列はコンマで区切り、全体を波括弧でくくります。 置換指定は、% と指示子の間に置きます。 例えば、「%{src,dst}p」とすると、「src」が「dst」に置換されたパス名が返されます。 これは、「依存ファイル名」から「タスク名」を取得するときに使うことができます。</p>
<p>パスマップの置換指定を使って、「srcディレクトリ以下のすべてのテキストファイルをdstディレクトリ以下にバックアップする」というRakefileを作ってみましょう。</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true"></a>sources = <span class="dt">FileList</span>[<span class="st">&quot;src/*.txt&quot;</span>]</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true"></a>names = sources.pathmap(<span class="st">&quot;%{src,dst}p&quot;</span>)</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true"></a></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true"></a>task <span class="st">default: </span>names</span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true"></a></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true"></a>mkdir <span class="st">&quot;dst&quot;</span> <span class="kw">unless</span> <span class="dt">Dir</span>.exist?(<span class="st">&quot;dst&quot;</span>)</span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true"></a>names.each <span class="kw">do</span> |name|</span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true"></a>  source = name.pathmap(<span class="st">&quot;%{dst,src}p&quot;</span>)</span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true"></a>  file name =&gt; source <span class="kw">do</span> |t|</span>
<span id="cb57-10"><a href="#cb57-10" aria-hidden="true"></a>    cp t.source, t.name</span>
<span id="cb57-11"><a href="#cb57-11" aria-hidden="true"></a>  <span class="kw">end</span></span>
<span id="cb57-12"><a href="#cb57-12" aria-hidden="true"></a><span class="kw">end</span></span></code></pre></div>
<p>2行目でパスマップの置換指定を使っています。</p>
<ul>
<li><code>sources</code>は配列<code>["src/a.txt", "src/b.txt", "src/c.txt"]</code>なので</li>
<li><code>names</code>は配列<code>["dst/a.txt", "dst/b.txt", "dst/c.txt"]</code>になる</li>
</ul>
<p>6行目では、バックアップ先のディレクトリ「dst」が存在しなければ作成します。 mkdirはFileUtilsモジュールのメソッドですが、このモジュールはRakeが自動的にrequireします。 8行目では文字列のpathmapメソッドを使って、タスク名から依存ファイル名を取得しています。</p>
<ul>
<li><code>name</code>が<code>dst/a.txt</code>または<code>dst/b.txt</code>または<code>dst/c.txt</code>なので</li>
<li><code>source</code>は<code>src/a.txt</code>または<code>src/b.txt</code>または<code>src/c.txt</code>になる</li>
</ul>
<p><code>example/example3</code>フォルダでは<code>Rakefile6</code>を使って試してください。</p>
<blockquote>
<p>[R]　正規表現とProcオブジェクトを使ったルールを用いることもできます。</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true"></a>sources = <span class="dt">FileList</span>[<span class="st">&quot;src/*.txt&quot;</span>]</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true"></a>names = sources.pathmap(<span class="st">&quot;%{src,dst}p&quot;</span>)</span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true"></a></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true"></a>task <span class="st">default: </span>names</span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true"></a></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true"></a>mkdir <span class="st">&quot;dst&quot;</span> <span class="kw">unless</span> <span class="dt">Dir</span>.exist?(<span class="st">&quot;dst&quot;</span>)</span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true"></a></span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true"></a>rule <span class="ot">/^dst\/.*\.txt$/</span> =&gt; proc {|tn| tn.pathmap(<span class="st">&quot;%{dst,src}p&quot;</span>)} <span class="kw">do</span> |t|</span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true"></a>  cp t.source, t.name</span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true"></a><span class="kw">end</span></span></code></pre></div>
<p>実行してみます。 （<code>example/example3</code>では<code>-f Rakefile7</code>をつけて実行してください）</p>
<pre><code>$ rm dst/*
$ rake
cp src/a.txt dst/a.txt
cp src/b.txt dst/b.txt
cp src/c.txt dst/c.txt
$</code></pre>
<p>ルールを使う方がよりシンプルなRakefileになります。</p>
</blockquote>
<h4 id="ディレクトリタスク">ディレクトリタスク</h4>
<p>ディレクトリタスクを作るdirectoryメソッドをこのセクションの最後に紹介します。 ディレクトリタスクは「タスク名のディレクトリが存在しなければ作成する」というタスクです。</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true"></a>directory <span class="st">&quot;a/b/c&quot;</span></span></code></pre></div>
<p>このディレクトリタスクは、「a/b/c」というディレクトリを作成するタスクです。 もし、cの親であるb、aも存在しなければ、それも作成します。</p>
<p>これを用いてdstディレクトリを作ることもできます。</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true"></a>sources = <span class="dt">FileList</span>[<span class="st">&quot;src/*.txt&quot;</span>]</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true"></a>names = sources.pathmap(<span class="st">&quot;%{src,dst}p&quot;</span>)</span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true"></a></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true"></a>task <span class="st">default: </span>names</span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true"></a>directory <span class="st">&quot;dst&quot;</span></span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true"></a></span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true"></a>names.each <span class="kw">do</span> |name|</span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true"></a>  source = name.pathmap(<span class="st">&quot;%{dst,src}p&quot;</span>)</span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true"></a>  file name =&gt; [source, <span class="st">&quot;dst&quot;</span>] <span class="kw">do</span> |t|</span>
<span id="cb61-10"><a href="#cb61-10" aria-hidden="true"></a>    cp t.source, t.name</span>
<span id="cb61-11"><a href="#cb61-11" aria-hidden="true"></a>  <span class="kw">end</span></span>
<span id="cb61-12"><a href="#cb61-12" aria-hidden="true"></a><span class="kw">end</span></span></code></pre></div>
<p>注意しなければいけないのは、ディレクトリタスクは「タスク」なので、Rakefileのロード実行中はそのタスクが定義されるだけだということです。 ディレクトリの作成にはタスク呼び出しが必要です。 そこで、「dst」を「dst/a.txt」「dst/b.txt」「dst/c.txt」の事前タスクに追加します。 このことにより、コピーの前にディレクトリの作成が行われます。 （<code>example/example3</code>では<code>-f Rakefile8</code>をつけて実行してください）</p>
<blockquote>
<p>｛Ｒ｝ルールを使って書き直してみます。</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true"></a>sources = <span class="dt">FileList</span>[<span class="st">&quot;src/*.txt&quot;</span>]</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true"></a>names = sources.pathmap(<span class="st">&quot;%{src,dst}p&quot;</span>)</span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true"></a></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true"></a>task <span class="st">default: </span>names</span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true"></a>directory <span class="st">&quot;dst&quot;</span></span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true"></a></span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true"></a>rule <span class="ot">/^dst\/.*\.txt$/</span> =&gt; [proc {|tn| tn.pathmap(<span class="st">&quot;%{dst,src}p&quot;</span>)}, <span class="st">&quot;dst&quot;</span>] <span class="kw">do</span> |t|</span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true"></a>  cp t.source, t.name</span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true"></a><span class="kw">end</span></span></code></pre></div>
<p>ルールの事前タスクにディレクトリタスクが追加されています。 （<code>example/example3</code>では<code>-f Rakefile9</code>をつけて実行してください）</p>
</blockquote>
<h3 id="rakeの応用１cleanとclobber">Rakeの応用（１）、CleanとClobber</h3>
<p>このセクションではPandocとRakeを組み合わせてHTMLファイルを作成します。 あわせて、CleanとClobberも説明します。</p>
<h4 id="pandoc">Pandoc</h4>
<p>まず、Pandocがどのようなアプリケーションなのかを説明します。 Pandocは、文書の形式を変換するアプリケーションです。 例えば、</p>
<ul>
<li>Wordの文書をHTML文書にする</li>
<li>Markdownの文書をPDF文書にする</li>
</ul>
<p>これ以外にも多数の文書形式がサポートされています。 詳しくは<a href="https://pandoc.org/">Pandocのウェブサイト</a>をご覧ください。</p>
<p>Pandocの最も簡単な使い方は、端末から</p>
<pre><code>pandoc -o 変換先ファイル 変換元ファイル</code></pre>
<p>という形で呼び出すことです。 Pandocはファイルの拡張子からファイル形式を判断します。</p>
<p>例として<code>example.docx</code>というワードファイルをHTMLにしてみましょう。 ワードファイルはこんな感じです。</p>
<div style="text-align:center;">
<p><img src="word.png" alt="ワード画面" style="max-width:100%;"></p>
</div>
<p>次のように端末から打ち込みます。 <code>-s</code>オプションを使っていますが、これについては後ほど説明します。</p>
<pre><code>$ pandoc -so example.html example.docx</code></pre>
<p>これにより、<code>example.html</code>というファイルができます。 ダブルクリックするとブラウザで内容が表示されます。</p>
<div style="text-align:center;">
<p><img src="html.png" alt="HTML画面" style="max-width:100%;"></p>
</div>
<p>画面の見栄えはともかく、ワードで書いた内容がHTMLとして表示されていることが確認できるでしょう。</p>
<p>では、どのようなHTMLが生成されたのでしょうか。</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode html"><code class="sourceCode html"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true"></a><span class="dt">&lt;!DOCTYPE </span>html<span class="dt">&gt;</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true"></a><span class="kw">&lt;html</span><span class="ot"> xmlns=</span><span class="st">&quot;http://www.w3.org/1999/xhtml&quot;</span><span class="ot"> lang=</span><span class="st">&quot;&quot;</span><span class="ot"> xml:lang=</span><span class="st">&quot;&quot;</span><span class="kw">&gt;</span></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true"></a><span class="kw">&lt;head&gt;</span></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true"></a>  <span class="kw">&lt;meta</span><span class="ot"> charset=</span><span class="st">&quot;utf-8&quot;</span> <span class="kw">/&gt;</span></span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true"></a>  <span class="kw">&lt;meta</span><span class="ot"> name=</span><span class="st">&quot;generator&quot;</span><span class="ot"> content=</span><span class="st">&quot;pandoc&quot;</span> <span class="kw">/&gt;</span></span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true"></a>  <span class="kw">&lt;meta</span><span class="ot"> name=</span><span class="st">&quot;viewport&quot;</span><span class="ot"> content=</span><span class="st">&quot;width=device-width, initial-scale=1.0, user-scalable=yes&quot;</span> <span class="kw">/&gt;</span></span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true"></a>  <span class="kw">&lt;title&gt;</span>example<span class="kw">&lt;/title&gt;</span></span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true"></a>  <span class="kw">&lt;style&gt;</span></span>
<span id="cb65-9"><a href="#cb65-9" aria-hidden="true"></a>    code{<span class="kw">white-space</span>: <span class="dv">pre-wrap</span><span class="op">;</span>}</span>
<span id="cb65-10"><a href="#cb65-10" aria-hidden="true"></a>    span<span class="fu">.smallcaps</span>{<span class="kw">font-variant</span>: <span class="dv">small-caps</span><span class="op">;</span>}</span>
<span id="cb65-11"><a href="#cb65-11" aria-hidden="true"></a>    span<span class="fu">.underline</span>{<span class="kw">text-decoration</span>: <span class="dv">underline</span><span class="op">;</span>}</span>
<span id="cb65-12"><a href="#cb65-12" aria-hidden="true"></a>    div<span class="fu">.column</span>{<span class="kw">display</span>: <span class="dv">inline-block</span><span class="op">;</span> <span class="kw">vertical-align</span>: <span class="dv">top</span><span class="op">;</span> <span class="kw">width</span>: <span class="dv">50</span><span class="dt">%</span><span class="op">;</span>}</span>
<span id="cb65-13"><a href="#cb65-13" aria-hidden="true"></a>    div<span class="fu">.hanging-indent</span>{<span class="kw">margin-left</span>: <span class="dv">1.5</span><span class="dt">em</span><span class="op">;</span> <span class="kw">text-indent</span>: <span class="dv">-1.5</span><span class="dt">em</span><span class="op">;</span>}</span>
<span id="cb65-14"><a href="#cb65-14" aria-hidden="true"></a>    ul<span class="fu">.task-list</span>{<span class="kw">list-style</span>: <span class="dv">none</span><span class="op">;</span>}</span>
<span id="cb65-15"><a href="#cb65-15" aria-hidden="true"></a>  <span class="kw">&lt;/style&gt;</span></span>
<span id="cb65-16"><a href="#cb65-16" aria-hidden="true"></a><span class="kw">&lt;/head&gt;</span></span>
<span id="cb65-17"><a href="#cb65-17" aria-hidden="true"></a><span class="kw">&lt;body&gt;</span></span>
<span id="cb65-18"><a href="#cb65-18" aria-hidden="true"></a><span class="kw">&lt;h2</span><span class="ot"> id=</span><span class="st">&quot;pandocのインストール&quot;</span><span class="kw">&gt;&lt;strong&gt;</span>P<span class="kw">&lt;/strong&gt;</span>andocのインストール<span class="kw">&lt;/h2&gt;</span></span>
<span id="cb65-19"><a href="#cb65-19" aria-hidden="true"></a><span class="kw">&lt;p&gt;</span>以下ではUbuntu22.04でのインストールを説明する。<span class="kw">&lt;/p&gt;</span></span>
<span id="cb65-20"><a href="#cb65-20" aria-hidden="true"></a><span class="kw">&lt;p&gt;</span>端末から、apt-getを使ってインストールする。<span class="kw">&lt;/p&gt;</span></span>
<span id="cb65-21"><a href="#cb65-21" aria-hidden="true"></a><span class="kw">&lt;p&gt;</span>$ sudo apt-get install pandoc<span class="kw">&lt;/p&gt;</span></span>
<span id="cb65-22"><a href="#cb65-22" aria-hidden="true"></a><span class="kw">&lt;p&gt;</span>これでインストールできるPandocはたいていの場合、最新版ではない。Pandocの最新版は、</span>
<span id="cb65-23"><a href="#cb65-23" aria-hidden="true"></a>そのホームページからダウンロードできる。インストーラがあるので、それを用いるのが簡単である。<span class="kw">&lt;/p&gt;</span></span>
<span id="cb65-24"><a href="#cb65-24" aria-hidden="true"></a><span class="kw">&lt;h2</span><span class="ot"> id=</span><span class="st">&quot;rubyのインストール&quot;</span><span class="kw">&gt;</span>Rubyのインストール<span class="kw">&lt;/h2&gt;</span></span>
<span id="cb65-25"><a href="#cb65-25" aria-hidden="true"></a><span class="kw">&lt;p&gt;</span>端末から、apt-getを使ってインストールする。<span class="kw">&lt;/p&gt;</span></span>
<span id="cb65-26"><a href="#cb65-26" aria-hidden="true"></a><span class="kw">&lt;p&gt;</span>$ sudo apt-get install ruby<span class="kw">&lt;/p&gt;</span></span>
<span id="cb65-27"><a href="#cb65-27" aria-hidden="true"></a><span class="kw">&lt;p&gt;</span>最新版のRubyをインストールにはrbenvが良いが、rbenvをマスターするには時間がかかる。</span>
<span id="cb65-28"><a href="#cb65-28" aria-hidden="true"></a>詳しくは<span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">&quot;https://github.com/rbenv/rbenv&quot;</span><span class="kw">&gt;</span>rbenv<span class="kw">&lt;/a&gt;</span>と</span>
<span id="cb65-29"><a href="#cb65-29" aria-hidden="true"></a><span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">&quot;https://github.com/rbenv/ruby-build&quot;</span><span class="kw">&gt;</span>ruby-build<span class="kw">&lt;/a&gt;</span>のウェブサイトを参照してほしい。<span class="kw">&lt;/p&gt;</span></span>
<span id="cb65-30"><a href="#cb65-30" aria-hidden="true"></a><span class="kw">&lt;/body&gt;</span></span>
<span id="cb65-31"><a href="#cb65-31" aria-hidden="true"></a><span class="kw">&lt;/html&gt;</span></span></code></pre></div>
<p>HTMLのソースコードから分かることで最も重要なことは、ヘッダが追加されていることです。 これはpandocに<code>-s</code>オプションをつけたからです。 <code>-s</code>をつけなければ、bodyタグで挟まれた本文の部分だけが生成されます。</p>
<h4 id="マークダウンをhtmlに変換する">マークダウンをHTMLに変換する</h4>
<p>ここからは、マークダウンをHTMLに変換し、さらにRakeで作業を自動化する方法を学びます。</p>
<p>ソースファイルはすべてカレントディレクトリにあるとします。 生成するHTMLはdocsディレクトリに作成します。 マークダウンファイルは、「sec1.md」「sec2.md」「sec3.md」「sec4.md」ですが、将来ファイルが増えても対応できるようにRakefileを作ります。</p>
<p>サンプルファイルは<code>example/example4</code>にあります。 その中の「sec1.md」から「sec4.md」は、このチュートリアルの第1章から第4章までのマークダウンファイルです。 （画像の部分は除いています）</p>
<p>Pandocでは、最初に%とともにメタデータを書きます。 これは、タイトル、著者、日付を表します。</p>
<pre><code>% はじめてのRake
% ToshioCP
% 2022/7/25</code></pre>
<p>タイトルはHTMLヘッダの<code>title</code>タグの内容にもなります。</p>
<p>Pandocで変換したHTMLは画面全面を使うので、横幅のあるPCでは広がりすぎて読みにくくなります。 それを解消するために、CSSファイル「style.css」を用意しました。</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode css"><code class="sourceCode css"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true"></a>body {</span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true"></a>  <span class="kw">padding-right</span>: <span class="dv">0.75</span><span class="dt">rem</span><span class="op">;</span></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true"></a>  <span class="kw">padding-left</span>: <span class="dv">0.75</span><span class="dt">rem</span><span class="op">;</span></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true"></a>  <span class="kw">margin-right</span>: <span class="bu">auto</span><span class="op">;</span></span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true"></a>  <span class="kw">margin-left</span>: <span class="bu">auto</span><span class="op">;</span></span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true"></a>}</span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true"></a></span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true"></a><span class="im">@media</span> (<span class="kw">min-width</span>: <span class="dv">576</span><span class="dt">px</span>) {</span>
<span id="cb67-9"><a href="#cb67-9" aria-hidden="true"></a>  body {</span>
<span id="cb67-10"><a href="#cb67-10" aria-hidden="true"></a>    <span class="kw">max-width</span>: <span class="dv">540</span><span class="dt">px</span><span class="op">;</span></span>
<span id="cb67-11"><a href="#cb67-11" aria-hidden="true"></a>  }</span>
<span id="cb67-12"><a href="#cb67-12" aria-hidden="true"></a>}</span>
<span id="cb67-13"><a href="#cb67-13" aria-hidden="true"></a><span class="im">@media</span> (<span class="kw">min-width</span>: <span class="dv">768</span><span class="dt">px</span>) {</span>
<span id="cb67-14"><a href="#cb67-14" aria-hidden="true"></a>  body {</span>
<span id="cb67-15"><a href="#cb67-15" aria-hidden="true"></a>    <span class="kw">max-width</span>: <span class="dv">720</span><span class="dt">px</span><span class="op">;</span></span>
<span id="cb67-16"><a href="#cb67-16" aria-hidden="true"></a>  }</span>
<span id="cb67-17"><a href="#cb67-17" aria-hidden="true"></a>}</span>
<span id="cb67-18"><a href="#cb67-18" aria-hidden="true"></a><span class="im">@media</span> (<span class="kw">min-width</span>: <span class="dv">992</span><span class="dt">px</span>) {</span>
<span id="cb67-19"><a href="#cb67-19" aria-hidden="true"></a>  body {</span>
<span id="cb67-20"><a href="#cb67-20" aria-hidden="true"></a>    <span class="kw">max-width</span>: <span class="dv">960</span><span class="dt">px</span><span class="op">;</span></span>
<span id="cb67-21"><a href="#cb67-21" aria-hidden="true"></a>  }</span>
<span id="cb67-22"><a href="#cb67-22" aria-hidden="true"></a>}</span>
<span id="cb67-23"><a href="#cb67-23" aria-hidden="true"></a><span class="im">@media</span> (<span class="kw">min-width</span>: <span class="dv">1200</span><span class="dt">px</span>) {</span>
<span id="cb67-24"><a href="#cb67-24" aria-hidden="true"></a>  body {</span>
<span id="cb67-25"><a href="#cb67-25" aria-hidden="true"></a>    <span class="kw">max-width</span>: <span class="dv">1140</span><span class="dt">px</span><span class="op">;</span></span>
<span id="cb67-26"><a href="#cb67-26" aria-hidden="true"></a>  }</span>
<span id="cb67-27"><a href="#cb67-27" aria-hidden="true"></a>}</span>
<span id="cb67-28"><a href="#cb67-28" aria-hidden="true"></a><span class="im">@media</span> (<span class="kw">min-width</span>: <span class="dv">1400</span><span class="dt">px</span>) {</span>
<span id="cb67-29"><a href="#cb67-29" aria-hidden="true"></a>  body {</span>
<span id="cb67-30"><a href="#cb67-30" aria-hidden="true"></a>    <span class="kw">max-width</span>: <span class="dv">1320</span><span class="dt">px</span><span class="op">;</span></span>
<span id="cb67-31"><a href="#cb67-31" aria-hidden="true"></a>  }</span>
<span id="cb67-32"><a href="#cb67-32" aria-hidden="true"></a>}</span></code></pre></div>
<p>このCSSはBootstrapのcontainerクラスの定義を参考に作りました。</p>
<p>このCSSは画面サイズに応じて、<code>body</code>の幅を調節するものです。 「レスポンシブデザイン」というテクニックです。 内容の詳細は省略しますが、興味のある人は「レスポンシブデザイン」で検索して説明サイトを見つけてください。</p>
<p>これを<code>style.css</code>という名前のファイルにしてRakefileのあるディレクトリに保存します。</p>
<p>Pandocで<code>-c</code>オプションを使うと、生成されたHTMLのヘッダで<code>style.css</code>を取り込むようになります。</p>
<h4 id="rakefileの作成">Rakefileの作成</h4>
<p>それでは、「sec1.md」から「sec4.md」までの4つのファイルからHTMLファイルを作るRakefileを作ってみましょう。 ここで、2つの考え方があります。</p>
<ul>
<li>sec1からsec4までを別々のHTMLファイルにし、それらをリンクでつなぐ。 目次を含むトップページはそれらとは別に作る</li>
<li>sec1.mdからsec4.mdまでを一つのファイルにつなげ、それをHTMLにする。</li>
</ul>
<p>どちらにも一長一短があります。 ここでは、作成の簡単な2番目の方法を採用しましょう。</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true"></a>sources = <span class="dt">FileList</span>[<span class="st">&quot;sec*.md&quot;</span>]</span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true"></a></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true"></a>task <span class="st">default: </span><span class="ot">%w[</span><span class="st">docs/はじめてのRake.html docs/style.css</span><span class="ot">]</span></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true"></a></span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true"></a>file <span class="st">&quot;docs/はじめてのRake.html&quot;</span> =&gt;<span class="ot"> %w[</span><span class="st">はじめてのRake.md docs</span><span class="ot">]</span> <span class="kw">do</span> |t|</span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true"></a>  sh <span class="st">&quot;pandoc -s --toc -c style.css -o </span><span class="ot">#{</span>t.name<span class="ot">}</span><span class="st"> </span><span class="ot">#{</span>t.source<span class="ot">}</span><span class="st">&quot;</span></span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true"></a><span class="kw">end</span></span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true"></a></span>
<span id="cb68-9"><a href="#cb68-9" aria-hidden="true"></a>file <span class="st">&quot;はじめてのRake.md&quot;</span> =&gt; sources <span class="kw">do</span> |t|</span>
<span id="cb68-10"><a href="#cb68-10" aria-hidden="true"></a>  firstrake = t.sources.inject(<span class="st">&quot;&quot;</span>) {|s1, s2| s1 &lt;&lt; <span class="dt">File</span>.read(s2) + <span class="st">&quot;\n&quot;</span>}</span>
<span id="cb68-11"><a href="#cb68-11" aria-hidden="true"></a>  <span class="dt">File</span>.write(<span class="st">&quot;はじめてのRake.md&quot;</span>, firstrake)</span>
<span id="cb68-12"><a href="#cb68-12" aria-hidden="true"></a><span class="kw">end</span></span>
<span id="cb68-13"><a href="#cb68-13" aria-hidden="true"></a></span>
<span id="cb68-14"><a href="#cb68-14" aria-hidden="true"></a>file <span class="st">&quot;docs/style.css&quot;</span> =&gt;<span class="ot"> %w[</span><span class="st">style.css docs</span><span class="ot">]</span> <span class="kw">do</span> |t|</span>
<span id="cb68-15"><a href="#cb68-15" aria-hidden="true"></a>  cp t.source, t.name</span>
<span id="cb68-16"><a href="#cb68-16" aria-hidden="true"></a><span class="kw">end</span></span>
<span id="cb68-17"><a href="#cb68-17" aria-hidden="true"></a></span>
<span id="cb68-18"><a href="#cb68-18" aria-hidden="true"></a>directory <span class="st">&quot;docs&quot;</span></span></code></pre></div>
<p>タスクの関連が少し複雑になっています。 ひとつひとつ見ていきましょう。</p>
<ul>
<li>デフォルトのタスク「default」の事前タスクは「docs/はじめてのRake.html」と「docs/style.css」です</li>
<li>「docs/はじめてのRake.html」はマークダウン「はじめてのRake.md」とディレクトリ「docs」に依存しています</li>
<li>「はじめてのRake.md」は4つのファイル（「sec1.md」から「sec4.md」）に依存しています</li>
<li>「docs/style.css」はそのコピー元の「style.css」とディレクトリ「docs」に依存しています</li>
<li>「docs」はディレクトリタスクで、directoryメソッドで定義されます</li>
</ul>
<p>6行目の<code>sh</code>は、Rubyの<code>system</code>メソッドと似ていて、引数を外部コマンドとして実行します。 6行目ではシェルを介してpandocを起動しています。 <code>sh</code>メソッドはRakeがFileUtilsに拡張したもので、オリジナルのFileUtilsにはありません。</p>
<p>Pandocの<code>--toc</code>オプションは目次を自動生成するオプションです。 デフォルトではマークダウンの見出しの<code>#</code>から<code>###</code>までが目次になります。</p>
<p>10行目の<code>inject</code>メソッドは畳み込みを行う、配列インスタンスのメソッドです。 引数を初期値として、配列の値を次々にs2に代入して計算し、結果を次のs1に代入します。 順を追って説明しましょう</p>
<ul>
<li>初期値は引数の空文字列<code>""</code>です。 それがブロックの<code>s1</code>に代入されます</li>
<li><code>s2</code>には最初の配列の要素である「sec1.md」が代入され、ブロック本体の<code>s1 &lt;&lt; File.read(s2) + "\n"</code>が実行されます。 これにより、<code>s1</code>の指す文字列には「sec1.mdの内容＋改行」が追加され、その文字列が<code>&lt;&lt;</code>メソッドの返り値になります。 その返り値が次に実行されるブロックの<code>s1</code>に代入されます。 （正しく説明すると複雑ですが、要するに<code>s1</code>に「sec1.mdの内容＋改行」が足されてそれが次の<code>s1</code>になると考えて差し支えありません）</li>
<li>2回目のブロック実行で、<code>s1</code>は「sec1.mdの内容＋改行」、<code>s2</code>には次の配列要素の「sec2.md」が代入されます。 ブロック本体が実行され、「s1」には「sec2.mdの内容＋改行」が追加されます。 その結果、<code>s1</code>は「sec1.mdの内容＋改行＋sec2.mdの内容＋改行」となります。 これが次の<code>s1</code>に代入されます。</li>
<li>3回目のブロック実行で、<code>s1</code>には前回実行の結果、<code>s2</code>には次の配列要素の「sec3.md」が代入されます。 前と同様に「sec3.mdの内容＋改行」が追加されます。</li>
<li>4回目（最後）のブロック実行で、<code>s1</code>には前回実行の結果、<code>s2</code>には次の配列要素の「sec4.md」が代入されます。 前と同様に「sec4.mdの内容＋改行」が追加されます。</li>
<li>以上の結果、<code>firstrake</code>には「sec1.mdの内容＋改行＋sec2.mdの内容＋改行＋sec3.mdの内容＋改行＋sec4.mdの内容＋改行」が代入されます。 要するに、4つのファイルを改行を挟んで結合した文字列になります。 11行目でそれがファイル「はじめてのRake.md」に保存されます。</li>
</ul>
<p>改行をファイルの末尾に足したのは、一般に「テキストファイルの末尾は改行がある場合とない場合がある」からです。 改行が無い場合に次のファイルを接続すると、2番めのファイルの先頭の文字が行頭に来ません。 すると、見出しの「#」が行頭からずれて見出しでなくなるということが起こりえます。 これを避けるために改行を足しているのです。</p>
<p>（<code>example/example4</code>では<code>-f Rakefile1</code>をつけてrakeを実行してください）</p>
<h4 id="cleanとclobber">cleanとclobber</h4>
<p>この処理において「はじてのRake.md」というファイルは中間ファイルです。 重要なのはソースファイルと結果ファイルだと考えれば、処理後に中間ファイルは削除したいと思うかもしれません。 そのような操作を行うのがcleanタスクです。 cleanタスクを使うには</p>
<ul>
<li><code>rake/clean</code>をrequireする</li>
<li>定数<code>CLEAN</code>の指すファイルリスト・オブジェクト（それも「CLEAN」と呼ぶことにします）に中間ファイルを追加する。 ファイルリストには配列と同様のメソッドが備わっているので、<code>&lt;&lt;</code>または<code>append</code>、<code>push</code>、<code>include</code>メソッドで追加ができる。</li>
</ul>
<p>また、結果ファイルも含めて全て生成ファイルを消去するタスクがclobberです。</p>
<ul>
<li>clobberタスクは、CLEANに登録されたファイルを削除する</li>
<li>さらに、ファイルリストCLOBBERに登録されたファイルも削除する</li>
</ul>
<p>以上を付け加えたRakefileは次のようになります。</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true"></a>require <span class="st">&#39;rake/clean&#39;</span></span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true"></a></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true"></a>sources = <span class="dt">FileList</span>[<span class="st">&quot;sec*.md&quot;</span>]</span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true"></a></span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true"></a>task <span class="st">default: </span><span class="ot">%w[</span><span class="st">docs/はじめてのRake.html docs/style.css</span><span class="ot">]</span></span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true"></a></span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true"></a>file <span class="st">&quot;docs/はじめてのRake.html&quot;</span> =&gt;<span class="ot"> %w[</span><span class="st">はじめてのRake.md docs</span><span class="ot">]</span> <span class="kw">do</span> |t|</span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true"></a>  sh <span class="st">&quot;pandoc -s --toc -c style.css -o </span><span class="ot">#{</span>t.name<span class="ot">}</span><span class="st"> </span><span class="ot">#{</span>t.source<span class="ot">}</span><span class="st">&quot;</span></span>
<span id="cb69-9"><a href="#cb69-9" aria-hidden="true"></a><span class="kw">end</span></span>
<span id="cb69-10"><a href="#cb69-10" aria-hidden="true"></a><span class="dt">CLEAN</span> &lt;&lt; <span class="st">&quot;はじめてのRake.md&quot;</span></span>
<span id="cb69-11"><a href="#cb69-11" aria-hidden="true"></a></span>
<span id="cb69-12"><a href="#cb69-12" aria-hidden="true"></a>file <span class="st">&quot;はじめてのRake.md&quot;</span> =&gt; sources <span class="kw">do</span> |t|</span>
<span id="cb69-13"><a href="#cb69-13" aria-hidden="true"></a>  firstrake = t.sources.inject(<span class="st">&quot;&quot;</span>) {|s1, s2| s1 &lt;&lt; <span class="dt">File</span>.read(s2) + <span class="st">&quot;\n&quot;</span>}</span>
<span id="cb69-14"><a href="#cb69-14" aria-hidden="true"></a>  <span class="dt">File</span>.write(<span class="st">&quot;はじめてのRake.md&quot;</span>, firstrake)</span>
<span id="cb69-15"><a href="#cb69-15" aria-hidden="true"></a><span class="kw">end</span></span>
<span id="cb69-16"><a href="#cb69-16" aria-hidden="true"></a></span>
<span id="cb69-17"><a href="#cb69-17" aria-hidden="true"></a>file <span class="st">&quot;docs/style.css&quot;</span> =&gt;<span class="ot"> %w[</span><span class="st">style.css docs</span><span class="ot">]</span> <span class="kw">do</span> |t|</span>
<span id="cb69-18"><a href="#cb69-18" aria-hidden="true"></a>  cp t.source, t.name</span>
<span id="cb69-19"><a href="#cb69-19" aria-hidden="true"></a><span class="kw">end</span></span>
<span id="cb69-20"><a href="#cb69-20" aria-hidden="true"></a></span>
<span id="cb69-21"><a href="#cb69-21" aria-hidden="true"></a>directory <span class="st">&quot;docs&quot;</span></span>
<span id="cb69-22"><a href="#cb69-22" aria-hidden="true"></a><span class="dt">CLOBBER</span> &lt;&lt; <span class="st">&quot;docs&quot;</span></span></code></pre></div>
<p>中間ファイルを削除するには （<code>example/example4</code>では<code>-f Rakefile2</code>をつけて実行してください）</p>
<pre><code>$ rake clean</code></pre>
<p>生成ファイル全てを削除するには</p>
<pre><code>$ rake clobber</code></pre>
<p>とします。</p>
<h3 id="rakeの応用２名前空間">Rakeの応用（２）、名前空間</h3>
<p>このセクションではPandocとRakeを組み合わせてPDFファイルを作成します。 あわせて、名前空間も説明します。</p>
<h4 id="pandocとlatexpdf">PandocとLaTeX、PDF</h4>
<p>PandocはMarkdownをPDFに変換することができます。 このときPandocはLaTeXを経由してPDFにします。</p>
<pre><code>Markdown =&gt; LaTeX =&gt; PDF</code></pre>
<p>経由する形式をConTeXt、roff ms、HTMLにすることもできますが、詳細はPandocのマニュアルで確認してください。 LaTeXからPDFに変換するのは直接Pandocが行うのではなく、LaTeXエンジンを使います。 LaTeXエンジンは、LaTeXをPDFなどに変換するアプリケーションで、pdfLaTeX、XeLaTeX、LuaLaTeXなどがあります。 ここではLuaLeTeXを使うことにします。</p>
<p>※　pLaTeX、upLaTeXなどのエンジンを好きな読者もいるかもしれません。 PandocはそれらをPDF作成エンジンとしてはサポートしていないようです。 それらのエンジンを使いたい場合はPandocでLaTeX文書を生成し、それをさらにそれぞれのエンジンでPDFにしてください。 Rakeの記述は若干複雑になります。</p>
<h4 id="準備">準備</h4>
<p>Pandocに対して、いくつか設定すべき項目があります。 それを、Markdownのはじめにメタデータで記述しておきます。 メタデータはYAML形式で書きます。 YAMLについての詳細は、<a href="https://ja.wikipedia.org/wiki/YAML">ウィキペディア</a>または<a href="https://yaml.org/">YAMLの公式ページ</a>を参照してください。</p>
<pre><code>% はじめてのRake
% ToshioCP
% 2022/7/29

---
documentclass: ltjsarticle
geometry: margin=2.4cm
toc: true
numbersections: true
secnumdepth: 2
---</code></pre>
<p>%で始まるメタデータは、前のセクションでHTMLを作ったときと同じです。 それぞれ、タイトル、著者、作成日時を表します。 <code>---</code>行で前後を囲まれた部分がYAMLのメタデータです。 ここで設定できる項目にどのようなものがあるかはPandocのマニュアルを見てください。 ここで設定している項目は次の通りです。</p>
<ul>
<li>LaTeX文書のドキュメントクラスに「ltjsarticle」を使う</li>
<li>geometryパッケージを用いてマージンが2.4cmになるようにレイアウトを変更する</li>
<li>目次を出力する</li>
<li>セクションに番号をふる（Pandocのデフォルトでは番号が振られません）</li>
<li>セクションに番号を降るのは大きい見出しから2番めまで。 「ltjsarticle」ドキュメントクラスでは最も大きい見出しが「section」で、2番めが「subsection」です。 これらはMarkdownの「#」と「##」のATX見出しに対応します。</li>
</ul>
<p>以上を「sec1.md」の最初に加えておきます。</p>
<p>今まで見出しに「###」から「#####」を使っていましたが、それではLaTeXのsection、subsectionにならないので、「#」から「###」までに変更が必要です。 手作業では面倒ですから、Rubyプログラムを作って変更します。</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true"></a>files = (<span class="dv">1</span>..<span class="dv">4</span>).map {|n| <span class="st">&quot;sec</span><span class="ot">#{</span>n<span class="ot">}</span><span class="st">.md&quot;</span>}</span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true"></a>files.each <span class="kw">do</span> |file|</span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true"></a>  s = <span class="dt">File</span>.read(file)</span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true"></a>  s.gsub!(<span class="ot">/^###/</span>,<span class="st">&quot;#&quot;</span>)</span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true"></a>  s.gsub!(<span class="ot">/^####/</span>,<span class="st">&quot;##&quot;</span>)</span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true"></a>  s.gsub!(<span class="ot">/^#####/</span>,<span class="st">&quot;###&quot;</span>)</span>
<span id="cb74-7"><a href="#cb74-7" aria-hidden="true"></a>  <span class="dt">File</span>.write(file,s)</span>
<span id="cb74-8"><a href="#cb74-8" aria-hidden="true"></a><span class="kw">end</span></span></code></pre></div>
<p>これを<code>ch_head.rb</code>というファイル名で保存し、実行します。 （サンプルファイルは<code>example/example5</code>に入っています）</p>
<pre><code>$ ruby ch_head.rb</code></pre>
<p>これで見出しの修正はできました。</p>
<p><code>sec2.md</code>のフェンスコードブロックの中に長すぎる行があります。 PDFではみ出してしまうので、調整しておきます。</p>
<pre><code>&gt; $ rake
&gt; rake aborted!
&gt; Rake::RuleRecursionOverflowError: Rule Recursion Too Deep: [ ... ...
&gt;
&gt; 最後の1行が長いので、分割して3行にする
&gt;
&gt; $ rake
&gt; rake aborted!
&gt; Rake::RuleRecursionOverflowError: Rule Recursion Too Deep: [~a.txt =&gt; ~a.txt =&gt;
&gt; ~a.txt =&gt; ~a.txt =&gt; ~a.txt =&gt; ~a.txt =&gt; ~a.txt =&gt; ~a.txt =&gt; ~a.txt =&gt; ~a.txt =&gt;
&gt; ~a.txt =&gt; ~a.txt =&gt; ~a.txt =&gt; ~a.txt =&gt; ~a.txt =&gt; ~a.txt =&gt; ~a.txt]</code></pre>
<h4 id="rakefileの作成-1">Rakefileの作成</h4>
<p>Rakefileは前回のものをPDFに合うように修正するので、比較的簡単に作れます。</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true"></a>require <span class="st">&#39;rake/clean&#39;</span></span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true"></a></span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true"></a>sources = <span class="dt">FileList</span>[<span class="st">&quot;sec*.md&quot;</span>]</span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true"></a></span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true"></a>task <span class="st">default: </span><span class="ot">%w[</span><span class="st">はじめてのRake.pdf</span><span class="ot">]</span></span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true"></a></span>
<span id="cb77-7"><a href="#cb77-7" aria-hidden="true"></a><span class="dt">CLEAN</span>.include <span class="ot">%w[</span><span class="st">はじめてのRake.tex</span><span class="ot">]</span></span>
<span id="cb77-8"><a href="#cb77-8" aria-hidden="true"></a></span>
<span id="cb77-9"><a href="#cb77-9" aria-hidden="true"></a>file <span class="st">&quot;はじめてのRake.pdf&quot;</span> =&gt; <span class="st">&quot;はじめてのRake.md&quot;</span> <span class="kw">do</span> |t|</span>
<span id="cb77-10"><a href="#cb77-10" aria-hidden="true"></a>  sh <span class="st">&quot;pandoc -s --pdf-engine lualatex -o </span><span class="ot">#{</span>t.name<span class="ot">}</span><span class="st"> </span><span class="ot">#{</span>t.source<span class="ot">}</span><span class="st">&quot;</span></span>
<span id="cb77-11"><a href="#cb77-11" aria-hidden="true"></a><span class="kw">end</span></span>
<span id="cb77-12"><a href="#cb77-12" aria-hidden="true"></a><span class="dt">CLEAN</span> &lt;&lt; <span class="st">&quot;はじめてのRake.md&quot;</span></span>
<span id="cb77-13"><a href="#cb77-13" aria-hidden="true"></a></span>
<span id="cb77-14"><a href="#cb77-14" aria-hidden="true"></a>file <span class="st">&quot;はじめてのRake.md&quot;</span> =&gt; sources <span class="kw">do</span> |t|</span>
<span id="cb77-15"><a href="#cb77-15" aria-hidden="true"></a>  firstrake = t.sources.inject(<span class="st">&quot;&quot;</span>) {|s1, s2| s1 &lt;&lt; <span class="dt">File</span>.read(s2) + <span class="st">&quot;\n&quot;</span>}</span>
<span id="cb77-16"><a href="#cb77-16" aria-hidden="true"></a>  <span class="dt">File</span>.write(<span class="st">&quot;はじめてのRake.md&quot;</span>, firstrake)</span>
<span id="cb77-17"><a href="#cb77-17" aria-hidden="true"></a><span class="kw">end</span></span>
<span id="cb77-18"><a href="#cb77-18" aria-hidden="true"></a></span>
<span id="cb77-19"><a href="#cb77-19" aria-hidden="true"></a><span class="dt">CLOBBER</span> &lt;&lt; <span class="st">&quot;はじめてのRake.pdf&quot;</span></span></code></pre></div>
<p>フォルダ<code>example/example5</code>の「sec1.md」から「sec4.md」は、すでにメタデータや見出しの修正が終わっています。</p>
<p>それでは、Rakeを実行してみましょう。 （<code>example/example5</code>で実行してください）</p>
<pre><code>$ rake
pandoc -s --pdf-engine lualatex -o はじめてのRake.pdf はじめてのRake.md
$</code></pre>
<p>今までよりも少し時間がかかります（約10秒）。</p>
<p>できあがったPDFを確かめてください。 MarkdownがこのようなPDFになるのは便利ですね。</p>
<p>HTMLはウェブでの公開、PDFは手元で見るのに適しています。 次のセクションでは、この2つの作業を1つのRakefileにまとめてみます。</p>
<h4 id="名前空間">名前空間</h4>
<p>2つの作業（HTML、PDFの作成）を1つのRakefileにするとき、タスクをわかりやすいように整理しておきたいところです。 一般に、整理されていないプログラムは後から修正するのが難しくなります。 これを「プログラムの保守性に問題がある」といいます。 「保守性を高める」ことはプログラム開発において非常に大切です。 ここでは名前空間を使い、プログラムの保守性を高めます。</p>
<p>名前空間は大きなプログラムを作るときに使われる一般的手法で、Rakeに限りません。 今回は次のようにします。</p>
<ul>
<li>HTMLを作成するタスクは名前空間「html」の中に入れる</li>
<li>PDFを作成するタスクは名前空間「pdf」の中に入れる</li>
</ul>
<p>名前空間を定義する構文は</p>
<pre><code>namespace 名前空間の名称 do
  タスクの定義
  ・・・・
end</code></pre>
<p>です。 今までは、それぞれの作業はdefaultタスクで起動していましたが、今回はそれぞれに「build」タスクを設けることにします。 「build」タスクは名前空間の下に定義するので</p>
<ul>
<li>html:build =&gt; HTMLをビルドするタスク</li>
<li>pdf:build =&gt; PDFをビルドするタスク</li>
</ul>
<p>となります。 このように名前空間の下のタスクは「名前空間名：タスク名」のように、コロンでつなげて表します。</p>
<p>名前空間は（ファイルタスクやディレクトリタスクでない）一般のタスクにのみ適用されます。 ファイルタスクはファイル名であり、名前空間の中で定義されたからといってファイル名が変わるわけではありません。 ファイルタスクを参照するときにも名前空間は使われません。</p>
<h4 id="準備-1">準備</h4>
<p>2つの作業を1つのRakefileにするために若干の準備が必要です。</p>
<ul>
<li>メタデータは、（タイトル、著者、日時を含め）すべてを別ファイルにする。 HTML用の「metadata_html.yml」とPDF用の「metadata_pdf.yml」を用意する。</li>
<li>PDFでは見出しの変更（例えば「###」を「#」にする）が必要なので、「sec1.md」の見出しを変更したものを「sec_pdf1.md」に保存する。 他のファイルも同様にする。 この操作はRakefileの中で記述する。</li>
</ul>
<p>まず、メタデータを作ります。</p>
<p>metadata_html.yml</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode yml"><code class="sourceCode yaml"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true"></a><span class="fu">title</span><span class="kw">:</span><span class="at"> はじめてのRake</span></span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true"></a><span class="fu">author</span><span class="kw">:</span><span class="at"> ToshioCP</span></span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true"></a><span class="fu">date</span><span class="kw">:</span><span class="at"> 2022/7/29</span></span></code></pre></div>
<p>metadata_pdf.yml</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode yml"><code class="sourceCode yaml"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true"></a><span class="fu">title</span><span class="kw">:</span><span class="at"> はじめてのRake</span></span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true"></a><span class="fu">author</span><span class="kw">:</span><span class="at"> ToshioCP</span></span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true"></a><span class="fu">date</span><span class="kw">:</span><span class="at"> 2022/7/29</span></span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true"></a><span class="fu">documentclass</span><span class="kw">:</span><span class="at"> ltjsarticle</span></span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true"></a><span class="fu">geometry</span><span class="kw">:</span><span class="at"> margin=2.4cm</span></span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true"></a><span class="fu">toc</span><span class="kw">:</span><span class="at"> </span><span class="ch">true</span></span>
<span id="cb81-7"><a href="#cb81-7" aria-hidden="true"></a><span class="fu">numbersections</span><span class="kw">:</span><span class="at"> </span><span class="ch">true</span></span>
<span id="cb81-8"><a href="#cb81-8" aria-hidden="true"></a><span class="fu">secnumdepth</span><span class="kw">:</span><span class="at"> </span><span class="dv">2</span></span></code></pre></div>
<p>「sec1.md」の最初にあった%で始まるメタデータを消去しておきます。 「sec1.md」などは、見出しが「###」から「#####」になっていることを確認しておいてください。</p>
<h4 id="rakefile">Rakefile</h4>
<p>では、Rakefileを書きましょう。</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true"></a>require <span class="st">&#39;rake/clean&#39;</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true"></a></span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true"></a>sources = <span class="dt">FileList</span>[<span class="st">&quot;sec1.md&quot;</span>, <span class="st">&quot;sec2.md&quot;</span>, <span class="st">&quot;sec3.md&quot;</span>, <span class="st">&quot;sec4.md&quot;</span>]</span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true"></a>sources_pdf = sources.pathmap(<span class="st">&quot;%{sec,sec_pdf}p&quot;</span>)</span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true"></a></span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true"></a>task <span class="st">default: </span><span class="ot">%w[</span><span class="st">html:build pdf:build</span><span class="ot">]</span></span>
<span id="cb82-7"><a href="#cb82-7" aria-hidden="true"></a></span>
<span id="cb82-8"><a href="#cb82-8" aria-hidden="true"></a>namespace <span class="st">&quot;html&quot;</span> <span class="kw">do</span></span>
<span id="cb82-9"><a href="#cb82-9" aria-hidden="true"></a>  task <span class="st">build: </span><span class="ot">%w[</span><span class="st">docs/はじめてのRake.html docs/style.css</span><span class="ot">]</span></span>
<span id="cb82-10"><a href="#cb82-10" aria-hidden="true"></a>  </span>
<span id="cb82-11"><a href="#cb82-11" aria-hidden="true"></a>  file <span class="st">&quot;docs/はじめてのRake.html&quot;</span> =&gt;<span class="ot"> %w[</span><span class="st">はじめてのRake.md docs</span><span class="ot">]</span> <span class="kw">do</span> |t|</span>
<span id="cb82-12"><a href="#cb82-12" aria-hidden="true"></a>    sh <span class="st">&quot;pandoc -s --toc --metadata-file=metadata_html.yml -c style.css -o </span><span class="ot">#{</span>t.name<span class="ot">}</span><span class="st"> </span><span class="ot">#{</span>t.source<span class="ot">}</span><span class="st">&quot;</span></span>
<span id="cb82-13"><a href="#cb82-13" aria-hidden="true"></a>  <span class="kw">end</span></span>
<span id="cb82-14"><a href="#cb82-14" aria-hidden="true"></a>  <span class="dt">CLEAN</span> &lt;&lt; <span class="st">&quot;はじめてのRake.md&quot;</span></span>
<span id="cb82-15"><a href="#cb82-15" aria-hidden="true"></a>  </span>
<span id="cb82-16"><a href="#cb82-16" aria-hidden="true"></a>  file <span class="st">&quot;はじめてのRake.md&quot;</span> =&gt; sources <span class="kw">do</span> |t|</span>
<span id="cb82-17"><a href="#cb82-17" aria-hidden="true"></a>    firstrake = t.sources.inject(<span class="st">&quot;&quot;</span>) {|s1, s2| s1 &lt;&lt; <span class="dt">File</span>.read(s2) + <span class="st">&quot;\n&quot;</span>}</span>
<span id="cb82-18"><a href="#cb82-18" aria-hidden="true"></a>    <span class="dt">File</span>.write(<span class="st">&quot;はじめてのRake.md&quot;</span>, firstrake)</span>
<span id="cb82-19"><a href="#cb82-19" aria-hidden="true"></a>  <span class="kw">end</span></span>
<span id="cb82-20"><a href="#cb82-20" aria-hidden="true"></a></span>
<span id="cb82-21"><a href="#cb82-21" aria-hidden="true"></a>  file <span class="st">&quot;docs/style.css&quot;</span> =&gt;<span class="ot"> %w[</span><span class="st">style.css docs</span><span class="ot">]</span> <span class="kw">do</span> |t|</span>
<span id="cb82-22"><a href="#cb82-22" aria-hidden="true"></a>    cp t.source, t.name</span>
<span id="cb82-23"><a href="#cb82-23" aria-hidden="true"></a>  <span class="kw">end</span></span>
<span id="cb82-24"><a href="#cb82-24" aria-hidden="true"></a></span>
<span id="cb82-25"><a href="#cb82-25" aria-hidden="true"></a>  directory <span class="st">&quot;docs&quot;</span></span>
<span id="cb82-26"><a href="#cb82-26" aria-hidden="true"></a>  <span class="dt">CLOBBER</span> &lt;&lt; <span class="st">&quot;docs&quot;</span></span>
<span id="cb82-27"><a href="#cb82-27" aria-hidden="true"></a><span class="kw">end</span></span>
<span id="cb82-28"><a href="#cb82-28" aria-hidden="true"></a></span>
<span id="cb82-29"><a href="#cb82-29" aria-hidden="true"></a>namespace <span class="st">&quot;pdf&quot;</span> <span class="kw">do</span></span>
<span id="cb82-30"><a href="#cb82-30" aria-hidden="true"></a>  task <span class="st">build: </span><span class="ot">%w[</span><span class="st">はじめてのRake.pdf</span><span class="ot">]</span></span>
<span id="cb82-31"><a href="#cb82-31" aria-hidden="true"></a></span>
<span id="cb82-32"><a href="#cb82-32" aria-hidden="true"></a>  file <span class="st">&quot;はじめてのRake.pdf&quot;</span> =&gt; <span class="st">&quot;はじめてのRake_pdf.md&quot;</span> <span class="kw">do</span> |t|</span>
<span id="cb82-33"><a href="#cb82-33" aria-hidden="true"></a>    sh <span class="st">&quot;pandoc -s --pdf-engine lualatex --metadata-file=metadata_pdf.yml -o </span><span class="ot">#{</span>t.name<span class="ot">}</span><span class="st"> </span><span class="ot">#{</span>t.source<span class="ot">}</span><span class="st">&quot;</span></span>
<span id="cb82-34"><a href="#cb82-34" aria-hidden="true"></a>  <span class="kw">end</span></span>
<span id="cb82-35"><a href="#cb82-35" aria-hidden="true"></a>  <span class="dt">CLEAN</span> &lt;&lt; <span class="st">&quot;はじめてのRake_pdf.md&quot;</span></span>
<span id="cb82-36"><a href="#cb82-36" aria-hidden="true"></a>  </span>
<span id="cb82-37"><a href="#cb82-37" aria-hidden="true"></a>  file <span class="st">&quot;はじめてのRake_pdf.md&quot;</span> =&gt; sources_pdf <span class="kw">do</span> |t|</span>
<span id="cb82-38"><a href="#cb82-38" aria-hidden="true"></a>    firstrake = t.sources.inject(<span class="st">&quot;&quot;</span>) {|s1, s2| s1 &lt;&lt; <span class="dt">File</span>.read(s2) + <span class="st">&quot;\n&quot;</span>}</span>
<span id="cb82-39"><a href="#cb82-39" aria-hidden="true"></a>    <span class="dt">File</span>.write(<span class="st">&quot;はじめてのRake_pdf.md&quot;</span>, firstrake)</span>
<span id="cb82-40"><a href="#cb82-40" aria-hidden="true"></a>  <span class="kw">end</span></span>
<span id="cb82-41"><a href="#cb82-41" aria-hidden="true"></a>  <span class="dt">CLEAN</span>.include sources_pdf</span>
<span id="cb82-42"><a href="#cb82-42" aria-hidden="true"></a>    </span>
<span id="cb82-43"><a href="#cb82-43" aria-hidden="true"></a>  sources_pdf.each <span class="kw">do</span> |dst|</span>
<span id="cb82-44"><a href="#cb82-44" aria-hidden="true"></a>    src = dst.sub(<span class="ot">/_pdf/</span>,<span class="st">&quot;&quot;</span>)</span>
<span id="cb82-45"><a href="#cb82-45" aria-hidden="true"></a>    file dst =&gt; src <span class="kw">do</span></span>
<span id="cb82-46"><a href="#cb82-46" aria-hidden="true"></a>      s = <span class="dt">File</span>.read(src)</span>
<span id="cb82-47"><a href="#cb82-47" aria-hidden="true"></a>      s = s.gsub(<span class="ot">/^###/</span>,<span class="st">&quot;#&quot;</span>).gsub(<span class="ot">/^####/</span>,<span class="st">&quot;##&quot;</span>).gsub(<span class="ot">/^#####/</span>,<span class="st">&quot;###&quot;</span>)</span>
<span id="cb82-48"><a href="#cb82-48" aria-hidden="true"></a>      <span class="dt">File</span>.write(dst, s)</span>
<span id="cb82-49"><a href="#cb82-49" aria-hidden="true"></a>    <span class="kw">end</span></span>
<span id="cb82-50"><a href="#cb82-50" aria-hidden="true"></a>  <span class="kw">end</span></span>
<span id="cb82-51"><a href="#cb82-51" aria-hidden="true"></a></span>
<span id="cb82-52"><a href="#cb82-52" aria-hidden="true"></a>  <span class="dt">CLOBBER</span> &lt;&lt; <span class="st">&quot;はじめてのRake.pdf&quot;</span></span>
<span id="cb82-53"><a href="#cb82-53" aria-hidden="true"></a><span class="kw">end</span></span></code></pre></div>
<p>ポイントを書きます</p>
<ul>
<li><code>sources</code>の定義を変えた。 PDFの作成で「sec_pdf1.md」のような中間ファイルが作らる。 <code>sources=FileList["sec*.md"]</code>だと、中間ファイルも拾ってしまうので、それを防ぐためにファイル名を具体的に書いた。</li>
<li>pandocのオプションに<code>--metadata-file=</code>オプションをつけてメタデータを取り込むようにした。</li>
<li>PDF作成では、見出しを変更した中間ファイル「sec_pdf1.md」などを使った。 また、見出しの変更は「sec_pdf1.md」などのファイルタスクのアクションとして定義した。 文字列の置換では<code>gsub!</code>ではなく<code>gsub</code>メソッドを使った。 両者は返り値が違うので、エクスクラメーションつきのメソッドは使わないほうが良い。 （置換が起こらなかったときに<code>nil</code>が返るのでバグになりやすい）</li>
</ul>
<p>異なる名前空間では同じ名前のタスクを定義しても名前の衝突は起こりません。 これは特にプロジェクトが大きいときに有利に働きます。</p>
<p>Rakeの実行においては</p>
<ul>
<li><code>rake</code>　＝＞　HTMLとPDFの両方が作られる</li>
<li><code>rake html:build</code>　＝＞　HTMLのみ作られる</li>
<li><code>rake pdf:build</code>　＝＞　PDFのみ作られる</li>
<li><code>rake clean</code>　＝＞　中間ファイルが削除される</li>
<li><code>rake clobber</code>　＝＞　生成されたファイルすべてが削除される</li>
</ul>
<p>このように使い分けをします。</p>
<h4 id="名前空間の利点">名前空間の利点</h4>
<p>名前空間はRakefileが大きいときに中身を整理できて便利です。 また、Rakefileはその一部をライブラリとして別ファイルにすることができます。 とりわけライブラリではタスク名が外部と衝突するのを防ぐために名前空間が有効です。</p>
<p>逆に、小規模なRakefileでは名前空間なしでも問題はありません。</p>
<p>名前の衝突回避以外に名前空間が役に立つのは、タスクの分類です。 コマンドラインから呼び出すタスクの数が多いとき、それらを名前空間で整理することが考えられます。 たとえば</p>
<pre><code># データベース関係のタスク
$ rake db:create
・・・・・
# 投稿関係のタスク
$ rake post:new
・・・・・</code></pre>
<p>のように、名前空間でそのタスクを分類するのです。 これによって、ユーザがコマンドを整理して覚えやすくなります。</p>
<h3 id="rakeのその他の機能">Rakeのその他の機能</h3>
<p>いままで触れなかったRakeの機能について解説します。 内容は、</p>
<ul>
<li>タスクの引数</li>
<li>ディスクリプション</li>
<li><code>rake</code>コマンドのオプション</li>
<li>Rakefileのサーチ</li>
<li>ライブラリ</li>
</ul>
<p>です。</p>
<p>マルチタスク、テストタスクは次のセクションで説明します。</p>
<h4 id="タスクの引数">タスクの引数</h4>
<p>コマンドラインからタスクを起動するときに引数を渡すことができます。 たとえば、</p>
<pre><code>$ rake hello[James]</code></pre>
<p>では、タスク名が<code>hello</code>で引数が<code>James</code>です。</p>
<p>複数の引数を渡したいときはコンマで区切ります。</p>
<pre><code>$ rake hello[James,Kelly]</code></pre>
<p>ここで注意が必要なのは、スペースを途中に入れてはいけないということです。 なぜなら、スペースはコマンドラインにおいて「引数の区切り」という特別な意味を持っているからです。</p>
<ul>
<li><code>rake hello[James,Kelly]</code> =&gt; コマンド<code>rake</code>に対して1つの引数<code>hello[James,Kelly]</code>が渡される。 rakeの中で<code>hello</code>がタスク名、<code>James</code>と<code>Kelly</code>がタスクへの引数という解釈が行われる。</li>
<li><code>rake hello[James, Kelly]</code> =&gt; コマンド<code>rake</code>に対して2つの引数<code>hello[James,</code>と<code>Kelly]</code>が渡される。 rakeは<code>hello[James,</code>が閉じカッコ無しなので、文字列全体をタスク名と解釈し、エラーになる。</li>
</ul>
<p>引数にスペースを入れたいときはダブルクォート（<code>"</code>）で囲めば大丈夫です。</p>
<pre><code>$ rake &quot;hello[James Robinson,Kelly Baker]&quot;</code></pre>
<p>一方、Rakefileにおけるタスク定義では、パラメータをタスク名の次にコンマで区切って書きます。</p>
<pre><code>task :a, [:param1, :param2]</code></pre>
<p>このタスク<code>a</code>はパラメータに<code>:param1</code>と<code>:param2</code>を持ちます。 パラメータの名前には通常シンボルを用いますが、文字列も可能です。 また、パラメータがひとつならば配列にしなくても構いません。</p>
<p>タスク<code>a</code>ではアクションがないので、引数の効果はありません。 引数の効果はアクションの中で発揮されます。</p>
<p>アクション（ブロック）には2番めのパラメータとして引数のインスタンス（TaskArgumentsクラスのインスタンス）が渡されます。</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true"></a>task <span class="st">:hello</span>, [<span class="st">:person1</span>, <span class="st">:person2</span>] <span class="kw">do</span> |t, args|</span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true"></a>  print <span class="st">&quot;Hello, </span><span class="ot">#{</span>args.person1<span class="ot">}</span><span class="st">.\n&quot;</span></span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true"></a>  print <span class="st">&quot;Hello, </span><span class="ot">#{</span>args.person2<span class="ot">}</span><span class="st">.\n&quot;</span></span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true"></a><span class="kw">end</span></span></code></pre></div>
<p>ブロック・パラメータは</p>
<ul>
<li>t =&gt; タスク「hello」のインスタンス</li>
<li>arg =&gt; 引数。TaskArgumentsクラスのインスタンス。</li>
</ul>
<p>です。</p>
<p>このとき、コマンドラインから次のようにタスクが呼び出されたとします。 （<code>example/example7</code>でオプション<code>-f Rakefile1</code>をつけて実行してください）</p>
<pre><code>$ rake hello[James,Kelly,David]
Hello, James.
Hello, Kelly.</code></pre>
<p>パラメータの数よりも引数の数が多いことに気づいた方もいると思います。 このように数が一致しなくてもエラーにはなりません。</p>
<p>TaskArgumentsクラスのインスタンスメソッドをいくつか列挙します。 上の例を使って説明します。</p>
<ul>
<li>[] =&gt; パラメータの値を返す。 <code>args[:person1]</code>とすると<code>James</code>が返される。</li>
<li>パラメータ名。パラメータの値を返す。 <code>args.person1</code>とすると<code>James</code>が返される。</li>
<li>to_a =&gt; 値の一覧を返す。 <code>args.to_a</code>とすると、<code>["James", "Kelly", "David"]</code>が返される。</li>
<li>extras =&gt; パラメータより引数が多いとき、余った引数が返される。 <code>args.extras</code>とすると、<code>["David"]</code>が返される。</li>
<li>to_hash =&gt; パラメータと値を組み合わせたハッシュを返す。 余った引数は除かれる。 <code>args.to_hash</code>とすると、<code>{:person1=&gt;"James", :person2=&gt;"Kelly"}</code>が返される。</li>
<li>each =&gt; <code>to_hash</code>のハッシュについてeachメソッドを実行する。</li>
</ul>
<blockquote>
<p>［Ｒ］上にあげた2番めのパラメータ名をメソッドとして使う方法は、実はメソッドとして定義されたものではありません。 Rakeは<code>method_missing</code>メソッド（BasicObjectのメソッド）を使い、メソッド名が定義されていなければパラメータ名の値を返すようにしています。 それであたかもパラメータ名のメソッドが実行されたように見えるのです。</p>
</blockquote>
<p>パラメータのデフォルト値を設定することも出来ます。 <code>with_defaults</code>メソッドにハッシュをつけて使います。</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true"></a>task <span class="st">:hello</span>, [<span class="st">:person1</span>, <span class="st">:person2</span>] <span class="kw">do</span> |t, args|</span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true"></a>  args.with_defaults <span class="st">person1: &quot;Dad&quot;</span>, <span class="st">person2: &quot;Mom&quot;</span></span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true"></a>  print <span class="st">&quot;Hello, </span><span class="ot">#{</span>args.person1<span class="ot">}</span><span class="st">.\n&quot;</span></span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true"></a>  print <span class="st">&quot;Hello, </span><span class="ot">#{</span>args.person2<span class="ot">}</span><span class="st">.\n&quot;</span></span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true"></a><span class="kw">end</span></span></code></pre></div>
<p>デフォルト値が<code>person1</code>に対して<code>Dad</code>、<code>person2</code>に対して<code>Mom</code>になりました。 実行してみます。 （<code>example/example7</code>でオプション<code>-f Rakefile2</code>をつけて実行してください）</p>
<pre><code>$ rake hello[James,Kelly,David]
Hello, James.
Hello, Kelly.
$ rake hello[,Kelly,David]
Hello, Dad.
Hello, Kelly.
$ rake hello
Hello, Dad.
Hello, Mom.</code></pre>
<p>タスク定義に事前タスクがある場合はパラメータに続けて<code>=&gt;</code>、事前タスクを書きます。</p>
<pre><code>task :hello, [:person1, :person2] =&gt; [:prerequisite1, :prerequisite2] do |t, args|
・・・・
end</code></pre>
<p>この例では<code>prerequisite1</code>と<code>prerequisite2</code>が事前タスクです。 事前タスクには引数が受け継がれますので、その中でパラメータを設定しておけば引数を使うことができます。</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true"></a>task <span class="st">:how</span>, [<span class="st">:person1</span>, <span class="st">:person2</span>] =&gt; <span class="st">:hello</span> <span class="kw">do</span> |t, args|</span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true"></a>  print <span class="st">&quot;How are you, </span><span class="ot">#{</span>args.person1<span class="ot">}</span><span class="st">?\n&quot;</span></span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true"></a>  print <span class="st">&quot;How are you, </span><span class="ot">#{</span>args.person2<span class="ot">}</span><span class="st">?\n&quot;</span></span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true"></a><span class="kw">end</span></span>
<span id="cb93-5"><a href="#cb93-5" aria-hidden="true"></a></span>
<span id="cb93-6"><a href="#cb93-6" aria-hidden="true"></a>task <span class="st">:hello</span>, [<span class="st">:person1</span>, <span class="st">:person2</span>] <span class="kw">do</span> |t, args|</span>
<span id="cb93-7"><a href="#cb93-7" aria-hidden="true"></a>  print <span class="st">&quot;Hello, </span><span class="ot">#{</span>args.person1<span class="ot">}</span><span class="st">.\n&quot;</span></span>
<span id="cb93-8"><a href="#cb93-8" aria-hidden="true"></a>  print <span class="st">&quot;Hello, </span><span class="ot">#{</span>args.person2<span class="ot">}</span><span class="st">.\n&quot;</span></span>
<span id="cb93-9"><a href="#cb93-9" aria-hidden="true"></a><span class="kw">end</span></span></code></pre></div>
<p>タスクhowに与えられる引数が事前タスクhelloにも与えられます。 （<code>example/example7</code>では<code>-f Rakefile3</code>をつけて実行してください）</p>
<pre><code>$ rake -f Rakefile3 how[James,Kelly,David]
Hello, James.
Hello, Kelly.
How are you, James?
How are you, Kelly?</code></pre>
<p>上記の例は実用的ではないですが、読者がRakefileの引数を理解する手助けにはなると思います。</p>
<p>引数以外に環境変数を使ってRakeに値を渡すこともできますが、これは古い方法です。 Rakeはバージョン0.8.0以前では引数をサポートしていませんでした。 そのときには環境変数を使うのが引数に代わる方法でした。 現時点では環境変数を引数として使う必要はありません。</p>
<h4 id="ディスクリプションとコマンドラインオプション">ディスクリプションとコマンドライン・オプション</h4>
<p>タスクの説明（ディスクリプション description）をつけることができます。 <code>desc</code>コマンドを使い、対象のタスクの前に記述します。</p>
<pre><code>desc &quot;あいさつをするタスク&quot;
task :hello do
  print &quot;Hello.\n&quot;
end</code></pre>
<p>説明の文字列はタスク定義時にタスクインスタンスにセットされます。 説明は<code>rake -T</code>または<code>rake -D</code>で表示されます。</p>
<pre><code>$ rake -T
rake hello  # あいさつをするタスク
$ rake -D
rake hello
    あいさつをするタスク

$</code></pre>
<p>表示されるのはディスクリプションがあるタスクだけです。 ディスクリプションは、ユーザがコマンドラインから呼び出す可能性のあるタスクにのみ付けるべきです。 例えば、前セクションのHTMLやPDFを作成するRakefileでは、</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true"></a>・・・・・</span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true"></a>desc <span class="st">&quot;HTMLとPDFの両方のファイルを作成します&quot;</span></span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true"></a>task <span class="st">default: </span><span class="ot">%w[</span><span class="st">html:build pdf:build</span><span class="ot">]</span></span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true"></a>・・・・・</span>
<span id="cb97-5"><a href="#cb97-5" aria-hidden="true"></a>namespace <span class="st">&quot;html&quot;</span> <span class="kw">do</span></span>
<span id="cb97-6"><a href="#cb97-6" aria-hidden="true"></a>  desc <span class="st">&quot;HTMLのファイルを作成します&quot;</span></span>
<span id="cb97-7"><a href="#cb97-7" aria-hidden="true"></a>  task <span class="st">build: </span><span class="ot">%w[</span><span class="st">docs/はじめてのRake.html docs/style.css</span><span class="ot">]</span></span>
<span id="cb97-8"><a href="#cb97-8" aria-hidden="true"></a>・・・・・</span>
<span id="cb97-9"><a href="#cb97-9" aria-hidden="true"></a>namespace <span class="st">&quot;pdf&quot;</span> <span class="kw">do</span></span>
<span id="cb97-10"><a href="#cb97-10" aria-hidden="true"></a>  desc <span class="st">&quot;PDFのファイルを作成します&quot;</span></span>
<span id="cb97-11"><a href="#cb97-11" aria-hidden="true"></a>  task <span class="st">build: </span><span class="ot">%w[</span><span class="st">はじめてのRake.pdf</span><span class="ot">]</span></span>
<span id="cb97-12"><a href="#cb97-12" aria-hidden="true"></a>・・・・・</span></code></pre></div>
<p>とするとコマンドラインからタスクの説明を見ることができます。 （<code>example/example6</code>で<code>-f Rakefile1</code>をつけて実行してください）</p>
<pre><code>$ rake -T
rake clean       # Remove any temporary products
rake clobber     # Remove any generated files
rake default     # HTMLとPDFの両方のファイルを作成します
rake html:build  # HTMLのファイルを作成します
rake pdf:build   # PDFのファイルを作成します</code></pre>
<p>これでユーザはどのタスクを使えばよいのかが分かります。 ディスクリプションはユーザのためのコメントだということがいえます。</p>
<p>これに対して開発者がプログラムのメモを残したいときはRubyのコメント（<code>#</code>から改行まで）を用います。</p>
<p><code>-T</code>オプションでは1行に収まる分しか表示されませんが、<code>-D</code>オプションではディスクリプションすべてを表示します。 また、これらのオプションではパターンをつけてタスクを限定することができます。</p>
<p>開発者向けのオプションとしては</p>
<ul>
<li><code>-AT</code> =&gt; すべての定義されたタスクを表示。 タスク呼び出し時に定義される事前タスクは、この時点では未定義のため表示されません。</li>
<li><code>-P</code> =&gt; タスクの依存関係を表示</li>
<li><code>-t</code>または<code>--trace</code> =&gt; すべてのバックトレースを表示</li>
</ul>
<p>とくに、<code>-t</code>または<code>--trace</code>オプションは開発の上で有益です。</p>
<h4 id="rakefileのサーチとライブラリ">Rakefileのサーチとライブラリ</h4>
<p>カレントディレクトリにRakefileが見つからない場合、上位のディレクトリを探していきます。 たとえば、カレントディレクトリが<code>a/b/c</code>で、Rakefileが<code>a</code>にあれば、</p>
<ul>
<li><code>a/b/c</code>でRakefileをサーチ　＝＞　ない。ひとつ上のディレクトリへ</li>
<li><code>a/b</code>でRakefileをサーチ　＝＞　ない。ひとつ上のディレクトリへ</li>
<li><code>a</code>でRakefileをサーチ　＝＞　ある。Rakefileを読み込んで実行。このときRakeのカレントディレクトリは<code>a</code>になる（<code>a/b/c</code>ではないことに注意）。</li>
</ul>
<p>また、<code>-f</code>オプションでRakefileを指定することも可能です。</p>
<p>Rakefileは1つのファイルに書くことが多いと思いますが、大きな規模の開発では複数のファイルに分けることが考えられます。 その際は</p>
<ul>
<li>ライブラリとなるRakefileには<code>.rake</code>の拡張子をつける（ファイル名はRakefileでなくてもよい）</li>
<li>ライブラリはトップディレクトリ（Rakefileのあるディレクトリ）直下の<code>rakelib</code>ディレクトリにおく</li>
</ul>
<p>このとき、Rakefileとライブラリにプログラム上の主従関係はないのですが、トップディレクトリのRakefileを「メインのRakefile」ということがあります。</p>
<h3 id="マルチタスクとテストタスク">マルチタスクとテストタスク</h3>
<p>ここでは、マルチタスクとテストタスクを説明します。</p>
<h4 id="マルチタスク">マルチタスク</h4>
<p>ここでいう「マルチタスク」はRakeの「multitask」メソッドを使った処理のことで、一般に使う「マルチタスク」ではありません。 タスクの中には互いに影響を及ぼさないタスクが複数存在することがあります。 そのとき、それらをひとつのスレッドで順に実行するよりも、マルチスレッドにして並行処理するほうが高速です。 そのためのメソッドが「multitask」です。</p>
<p>例としてテキストファイル中の文字を「文字ごとに」カウントするプログラム<code>fre.rb</code>を用います。 <code>example/example8</code>フォルダにこのプログラムが入っていますが、そのソースリストの解説は省略します。 このプログラムは引数で与えられたファイルを捜査し、文字ごとの出現頻度を調べ、文字数と上位10位の文字とカウントを表示します。</p>
<pre><code>$ ruby fre.rb ../../sec1.md
総文字数： 7828
頻度の上位10文字
&quot;\n&quot;   =&gt;  409
&quot; &quot;    =&gt;  262
&quot;e&quot;    =&gt;  229
&quot;`&quot;    =&gt;  217
&quot;a&quot;    =&gt;  190
&quot;の&quot;    =&gt;  162
&quot;す&quot;    =&gt;  160
&quot;を&quot;    =&gt;  142
&quot;k&quot;    =&gt;  141
&quot;で&quot;    =&gt;  126</code></pre>
<p>これにより、総文字数は7828で、最も多く出現したのが改行で409個です。 改行や空白が上位に来ていて、あまり意味がないかもしれませんね。 もう少し先まで表示すれば日本語文字の頻度が分かり、より実用的かもしれません。 その場合は、ほんの少しプログラムを変えれば上位20位あるいは30位にできます。 あるいは、改行などの区切り文字を表示しないようにもできます。</p>
<p>当初の予想では、ある程度時間がかかると思っていたのですが、実行してみると一瞬で終わってしまいました。 マルチタスクのありがたさを実感するには、時間がかかるプログラムの方が良いのですが、更にもうひとつプログラムを書くのも面倒なので、これで説明します。 申し訳ありません。</p>
<p>さて、2つのRakefileを用意します。 <code>Rakefile1</code>と<code>Rakefile2</code>です。</p>
<p>Rakefile1</p>
<div class="sourceCode" id="cb100"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true"></a>require <span class="st">&#39;rake/clean&#39;</span></span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true"></a></span>
<span id="cb100-3"><a href="#cb100-3" aria-hidden="true"></a>files = <span class="dt">FileList</span>[<span class="st">&quot;../../sec*.md&quot;</span>]</span>
<span id="cb100-4"><a href="#cb100-4" aria-hidden="true"></a></span>
<span id="cb100-5"><a href="#cb100-5" aria-hidden="true"></a>task <span class="st">default: </span>files</span>
<span id="cb100-6"><a href="#cb100-6" aria-hidden="true"></a></span>
<span id="cb100-7"><a href="#cb100-7" aria-hidden="true"></a>files.each <span class="kw">do</span> |f|</span>
<span id="cb100-8"><a href="#cb100-8" aria-hidden="true"></a>  task f <span class="kw">do</span></span>
<span id="cb100-9"><a href="#cb100-9" aria-hidden="true"></a>    sh <span class="st">&quot;ruby fre.rb </span><span class="ot">#{</span>f<span class="ot">}</span><span class="st"> &gt; </span><span class="ot">#{</span>f.pathmap(<span class="st">&#39;%f&#39;</span>).ext(<span class="st">&#39;txt&#39;</span>)<span class="ot">}</span><span class="st">&quot;</span></span>
<span id="cb100-10"><a href="#cb100-10" aria-hidden="true"></a>  <span class="kw">end</span></span>
<span id="cb100-11"><a href="#cb100-11" aria-hidden="true"></a><span class="kw">end</span></span>
<span id="cb100-12"><a href="#cb100-12" aria-hidden="true"></a></span>
<span id="cb100-13"><a href="#cb100-13" aria-hidden="true"></a><span class="dt">CLEAN</span>.include files.pathmap(<span class="st">&#39;%f&#39;</span>).ext(<span class="st">&#39;txt&#39;</span>)</span></code></pre></div>
<p>この<code>Rakefile1</code>は「sec1.md」から「sec7.md」までのファイルの文字出現頻度を調べ、その結果をファイルに書き出します。</p>
<p><code>Rakefile2</code>もほぼ同様で、異なるのは出力ファイル名を違うものにしたことと、5行目の<code>task</code>メソッドを<code>multitask</code>メソッドをに代えたことです。</p>
<div class="sourceCode" id="cb101"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true"></a>multitask <span class="st">default: </span>files</span></code></pre></div>
<p><code>multitask</code>メソッドではタスクを別々のスレッドで並行処理をしますので、速度上の効果が期待できます。 それを調べるためにRubyのBenchmarkライブラリを使って時間計測をしました。 プログラム<code>bm.rb</code>は次の通りです。</p>
<div class="sourceCode" id="cb102"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true"></a>require <span class="st">&#39;benchmark&#39;</span></span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true"></a></span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true"></a><span class="dt">Benchmark</span>.bm <span class="kw">do</span> |x|</span>
<span id="cb102-4"><a href="#cb102-4" aria-hidden="true"></a>  x.report {system <span class="st">&quot;rake -f Rakefile1 -q&quot;</span>}</span>
<span id="cb102-5"><a href="#cb102-5" aria-hidden="true"></a>  x.report {system <span class="st">&quot;rake -f Rakefile2 -q&quot;</span>}</span>
<span id="cb102-6"><a href="#cb102-6" aria-hidden="true"></a><span class="kw">end</span></span></code></pre></div>
<p>ベンチマークライブラリの使い方は<a href="https://docs.ruby-lang.org/ja/3.0/library/benchmark.html">Rubyのドキュメント</a>を参考にしてください。 実行してみます。</p>
<pre><code>$ ruby bm.rb
       user     system      total        real
   0.000187   0.000033   0.569095 (  0.569198)
   0.000162   0.000029   0.959387 (  0.315929)</code></pre>
<p>上がtaskメソッドで順にひとつひとつを処理した場合、下がmultitaskメソッドで並行処理をした場合です。 両者とも一瞬で終わってしまうので、体感的には変わらないのですが、上の結果をみるとmultitaskの方が1.8倍速くなっています。</p>
<p>マルチタスクが使えるためには、それぞれのタスクが干渉しないことが前提です。 タスクの組み立てを上手くして干渉しないようにすれば、multitaskメソッドで速度の改善が期待できます。</p>
<h4 id="テストタスク">テストタスク</h4>
<p>最後のトピックはテストタスクです。 現在のRubyの標準テストライブラリはminitestです。 minitestの情報はその<a href="https://www.rubydoc.info/gems/minitest">ホームページ</a>にあります。 何回か経験すればテストのコツのようなものは分かると思います。</p>
<p>通常、テストのプログラムは<code>test</code>ディレクトリに集めておくことが多いです。 そのディレクトリにRakefileを置き、テストをマルチタスクで高速に行うことができます。 例が<a href="https://docs.ruby-lang.org/ja/3.1/class/Rake=3a=3aTestTask.html">Rubyのホームページ</a>にありますので、参考にしてください。</p>
<p>ここで実例を作るのはかなり大きな作業になりますので、ここではRakefileとその解説のみにとどめます。</p>
<div class="sourceCode" id="cb104"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true"></a>require <span class="st">&quot;rake/testtask&quot;</span></span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true"></a></span>
<span id="cb104-3"><a href="#cb104-3" aria-hidden="true"></a><span class="dt">FileList</span>[<span class="st">&#39;test*.rb&#39;</span>].each <span class="kw">do</span> |file|</span>
<span id="cb104-4"><a href="#cb104-4" aria-hidden="true"></a>  <span class="dt">Rake</span>::<span class="dt">TestTask</span>.new <span class="kw">do</span> |t|</span>
<span id="cb104-5"><a href="#cb104-5" aria-hidden="true"></a>    t.libs &lt;&lt; <span class="st">&quot;test&quot;</span></span>
<span id="cb104-6"><a href="#cb104-6" aria-hidden="true"></a>    t.test_files = [file]</span>
<span id="cb104-7"><a href="#cb104-7" aria-hidden="true"></a>    t.verbose = <span class="dv">true</span></span>
<span id="cb104-8"><a href="#cb104-8" aria-hidden="true"></a>  <span class="kw">end</span></span>
<span id="cb104-9"><a href="#cb104-9" aria-hidden="true"></a><span class="kw">end</span></span></code></pre></div>
<p>この例では、テスト用のRubyファイルが「test」から始まるファイル名（通常は複数個のファイル）とします。</p>
<ul>
<li><code>testtask</code>をrequireすることが必要です</li>
<li>3行目でテストファイルのファイルリストを作り、eachメソッドでそのひとつひとつに対してブロックでタスクを作ります</li>
<li><code>Rake::TestTask.new</code>でテストタスクを生成します。 一般のタスクにはtaskメソッドがありますが、テストタスクはnewメソッドでインスタンスを作ります。</li>
<li>ブロックの引数<code>t</code>は生成されたテストタスクです。</li>
<li><code>t.libs</code>はライブラリのロードパスで、<code>test</code>ディレクトリを追加します</li>
<li><code>test_files</code>メソッドで明示的にテストファイルを示します。 ひとつのテストタスクにひとつのテストプログラムを入れていますが、複数のファイルを入れることも可能です。 その場合、コンフリクトが起こらないようにしてください。 テストプログラムがファイルの読み書きをする場合は特に注意が必要です。 場合によりますが、このプログラムのように異なるプログラムを異なるテストタスクに登録することで問題を避けることもできます。</li>
<li><code>t.verbose=true</code>にすると、テストの実行結果の詳細を表示します。</li>
</ul>
<p>コマンドラインから、testタスクを実行します。</p>
<pre><code>$ rake test</code></pre>
<h4 id="おわりに">おわりに</h4>
<p>以上、Rakeの使い方について初心者向けに解説してきました。 最後は難しい内容になってしまったかと思いますが、前半だけ理解できればRakeは使えるようになります。 後半はある程度使えるようになってから、再学習しても良いと思います。</p>
<p>このチュートリアル自体もRakeを使ってマークダウンからHTMLを生成し、<a href="https://toshiocp.github.io/Rake-tutorial-for-beginners-jp/%E3%81%AF%E3%81%98%E3%82%81%E3%81%A6%E3%81%AERake.html">Github Pages</a>に表示するようになっています。 トップディレクトリにあるRakefileも参考として見てください。</p>
<p>チュートリアルを最後までお読みいただき、ありがとうございました。</p>
<p>Happy Hacking!</p>
</body>
</html>
